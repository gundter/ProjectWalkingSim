---
phase: 05-monster-behaviors
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - Source/ProjectWalkingSim/Public/AI/Tasks/STT_ChasePlayer.h
  - Source/ProjectWalkingSim/Private/AI/Tasks/STT_ChasePlayer.cpp
  - Source/ProjectWalkingSim/Public/AI/Tasks/STT_SearchArea.h
  - Source/ProjectWalkingSim/Private/AI/Tasks/STT_SearchArea.cpp
  - Source/ProjectWalkingSim/Public/AI/Tasks/STT_ReturnToNearestWaypoint.h
  - Source/ProjectWalkingSim/Private/AI/Tasks/STT_ReturnToNearestWaypoint.cpp
autonomous: true

must_haves:
  truths:
    - "Chase task continuously moves toward player using MoveToActor and tracks LOS lost timer"
    - "Chase task returns Succeeded when player is within grab range (triggers GrabAttack transition)"
    - "Chase task returns Failed when LOS is lost for longer than timeout (triggers Search transition)"
    - "Search task moves to last-known position then 2-3 random nearby NavMesh points"
    - "Search task succeeds after search duration expires (returns to lower states)"
    - "ReturnToNearestWaypoint task navigates to closest patrol waypoint and sets CurrentWaypointIndex"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/AI/Tasks/STT_ChasePlayer.h"
      provides: "FSTT_ChasePlayer State Tree task with LOS timer and grab range check"
      contains: "FSTT_ChasePlayer"
    - path: "Source/ProjectWalkingSim/Public/AI/Tasks/STT_SearchArea.h"
      provides: "FSTT_SearchArea State Tree task with random NavMesh point generation"
      contains: "FSTT_SearchArea"
    - path: "Source/ProjectWalkingSim/Public/AI/Tasks/STT_ReturnToNearestWaypoint.h"
      provides: "FSTT_ReturnToNearestWaypoint task for post-search patrol resumption"
      contains: "FSTT_ReturnToNearestWaypoint"
  key_links:
    - from: "STT_ChasePlayer"
      to: "AAIController::MoveToActor"
      via: "EnterState issues MoveToActor, Tick monitors LOS"
      pattern: "MoveToActor.*ChaseTarget"
    - from: "STT_SearchArea"
      to: "UNavigationSystemV1::GetRandomReachablePointInRadius"
      via: "EnterState generates search points"
      pattern: "GetRandomReachablePointInRadius"
    - from: "STT_ChasePlayer"
      to: "WendigoCharacter::SetLastKnownPlayerLocation"
      via: "Tick updates last-known position while LOS maintained"
      pattern: "SetLastKnownPlayerLocation"
    - from: "STT_ReturnToNearestWaypoint"
      to: "PatrolRouteActor::GetWaypoint"
      via: "EnterState finds nearest waypoint by DistSquared"
      pattern: "DistSquared.*GetWaypoint"
---

<objective>
Create the three core hunt-cycle State Tree tasks: Chase, Search, and ReturnToNearestWaypoint.

Purpose: These three tasks form the complete predator cycle. Chase pursues the player at 575 cm/s using MoveToActor. When the player breaks LOS for 3 seconds, chase transitions to Search. Search moves to the last-known position then checks 2-3 random NavMesh points. After search duration expires, ReturnToNearestWaypoint navigates to the closest patrol waypoint for seamless patrol resumption.

Output: Three new State Tree task files (header + cpp each) in Source/ProjectWalkingSim/Public/AI/Tasks/ and Private/AI/Tasks/.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-monster-behaviors/05-RESEARCH.md
@.planning/phases/05-monster-behaviors/05-01-SUMMARY.md

@Source/ProjectWalkingSim/Public/AI/Tasks/STT_InvestigateLocation.h
@Source/ProjectWalkingSim/Private/AI/Tasks/STT_InvestigateLocation.cpp
@Source/ProjectWalkingSim/Public/AI/Tasks/STT_PatrolMoveToWaypoint.h
@Source/ProjectWalkingSim/Private/AI/Tasks/STT_PatrolMoveToWaypoint.cpp
@Source/ProjectWalkingSim/Public/AI/WendigoCharacter.h
@Source/ProjectWalkingSim/Public/AI/MonsterAITypes.h
@Source/ProjectWalkingSim/Public/AI/PatrolRouteActor.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create STT_ChasePlayer task</name>
  <files>
    Source/ProjectWalkingSim/Public/AI/Tasks/STT_ChasePlayer.h
    Source/ProjectWalkingSim/Private/AI/Tasks/STT_ChasePlayer.cpp
  </files>
  <action>
    Create a new State Tree task following the established FSTT_ pattern from STT_InvestigateLocation.

    **STT_ChasePlayer.h:**
    - Include StateTreeTaskBase.h, StateTreeLinker.h, StateTreeExecutionContext.h (same as all existing tasks).
    - Forward declare `class AAIController;`
    - `FSTT_ChasePlayerInstanceData` USTRUCT:
      - `float LOSLostTimer = 0.0f;` (seconds since last visual contact)
      - `bool bMoveRequestActive = false;`
      - `TWeakObjectPtr<AActor> ChaseTarget;` (cached player reference)
    - `FSTT_ChasePlayer` USTRUCT with `meta = (DisplayName = "Chase Player")`, inherits FStateTreeTaskCommonBase:
      - `using FInstanceDataType = FSTT_ChasePlayerInstanceData;`
      - Override GetInstanceDataType, Link, EnterState, Tick, ExitState
      - `TStateTreeExternalDataHandle<AAIController> ControllerHandle;`
      - UPROPERTY EditAnywhere: `float ChaseSpeed = AIConstants::WendigoChaseSpeed;` (575.0f)
      - UPROPERTY EditAnywhere: `float LOSLostTimeout = AIConstants::LOSLostTimeout;` (3.0f)
      - UPROPERTY EditAnywhere: `float GrabRange = AIConstants::GrabRange;` (150.0f)
      - UPROPERTY EditAnywhere: `float AcceptanceRadius = 50.0f;`

    **STT_ChasePlayer.cpp:**
    - Include: AIController.h, WendigoCharacter.h, SuspicionComponent.h, MonsterAITypes.h, GameFramework/CharacterMovementComponent.h, Navigation/PathFollowingComponent.h, SereneLogChannels.h
    - `Link`: Link ControllerHandle.
    - `EnterState`:
      1. Get controller, cast pawn to AWendigoCharacter, fail if nullptr.
      2. Find chase target: use Kismet or `UGameplayStatics::GetPlayerPawn(World, 0)`. Store in InstanceData.ChaseTarget.
      3. If no valid chase target, return Failed.
      4. Set WendigoCharacter BehaviorState to Chasing via SetBehaviorState.
      5. Set MaxWalkSpeed to ChaseSpeed.
      6. Set focus on chase target via `Controller.SetFocus(ChaseTarget.Get())` for head tracking.
      7. Issue `Controller.MoveToActor(ChaseTarget.Get(), AcceptanceRadius, true, true, true, nullptr, true)`. bCanStrafe = true, bAllowPartialPath = true.
      8. Handle MoveToActor failure: fall back by storing last-known location.
      9. Reset LOSLostTimer = 0.
      10. Return Running.
    - `Tick`:
      1. Get controller and InstanceData.
      2. If ChaseTarget is invalid (expired weak ptr), return Failed.
      3. Check LOS: `Controller.LineOfSightTo(ChaseTarget.Get())`.
      4. If can see player: reset LOSLostTimer to 0, update Wendigo->SetLastKnownPlayerLocation(ChaseTarget->GetActorLocation()).
      5. If cannot see player: increment LOSLostTimer by DeltaTime. If >= LOSLostTimeout, return Failed (triggers transition to Search state).
      6. Check grab range: `FVector::Dist(Controller.GetPawn()->GetActorLocation(), ChaseTarget->GetActorLocation())`. If <= GrabRange AND bCanSeePlayer, return Succeeded (triggers transition to GrabAttack).
      7. If MoveToActor path failed (GetMoveStatus returns Idle while still chasing), re-issue MoveToActor. This handles the pitfall where player leaves NavMesh temporarily.
      8. Return Running.
    - `ExitState`:
      1. Restore MaxWalkSpeed to AIConstants::WendigoWalkSpeed (always restore to baseline, not "previous" -- avoids speed leak).
      2. Stop movement if active: `Controller.StopMovement()`.
      3. Clear focus: `Controller.ClearFocus(EAIFocusPriority::Gameplay)`.

    CRITICAL: Use `AAIController::LineOfSightTo` not custom raycasts. Use `MoveToActor` not repeated MoveToLocation -- MoveToActor auto-updates destination.
    CRITICAL: Store LastKnownPlayerLocation on AWendigoCharacter (persistent), NOT in instance data (resets on re-entry).
  </action>
  <verify>
    Compile cleanly. Verify the file follows the same include pattern and structure as STT_InvestigateLocation.h/cpp. Check that ExitState always restores WendigoWalkSpeed (not a variable -- the constant).
  </verify>
  <done>
    - STT_ChasePlayer compiles and follows established FSTT_ pattern
    - EnterState sets chase speed + MoveToActor + SetFocus
    - Tick monitors LOS timer and grab range
    - ExitState restores baseline speed, stops movement, clears focus
    - Succeeded = grab range reached, Failed = LOS lost timeout
  </done>
</task>

<task type="auto">
  <name>Task 2: Create STT_SearchArea and STT_ReturnToNearestWaypoint tasks</name>
  <files>
    Source/ProjectWalkingSim/Public/AI/Tasks/STT_SearchArea.h
    Source/ProjectWalkingSim/Private/AI/Tasks/STT_SearchArea.cpp
    Source/ProjectWalkingSim/Public/AI/Tasks/STT_ReturnToNearestWaypoint.h
    Source/ProjectWalkingSim/Private/AI/Tasks/STT_ReturnToNearestWaypoint.cpp
  </files>
  <action>
    **STT_SearchArea** -- creates search point list and navigates through them:

    **STT_SearchArea.h:**
    - `FSTT_SearchAreaInstanceData` USTRUCT:
      - `TArray<FVector> SearchPoints;` (last-known + random navmesh points)
      - `int32 CurrentSearchIndex = 0;`
      - `bool bMoveRequestActive = false;`
      - `float TimeAtCurrentPoint = 0.0f;` (linger timer at each search point)
      - `float TotalSearchTime = 0.0f;` (overall search duration timer)
    - `FSTT_SearchArea` USTRUCT with `meta = (DisplayName = "Search Area")`:
      - `TStateTreeExternalDataHandle<AAIController> ControllerHandle;`
      - UPROPERTY: `float SearchSpeed = AIConstants::WendigoSearchSpeed;` (180.0f)
      - UPROPERTY: `float SearchRadius = AIConstants::SearchRadius;` (600.0f)
      - UPROPERTY: `int32 NumRandomPoints = AIConstants::NumSearchPoints;` (3)
      - UPROPERTY: `float MaxSearchDuration = AIConstants::SearchDuration;` (18.0f)
      - UPROPERTY: `float LingerDuration = 3.0f;` (seconds to pause and look around at each search point)
      - UPROPERTY: `float AcceptanceRadius = 100.0f;`

    **STT_SearchArea.cpp:**
    - `EnterState`:
      1. Get controller and Wendigo pawn.
      2. Set BehaviorState to Searching.
      3. Set MaxWalkSpeed to SearchSpeed.
      4. Build SearchPoints array:
         - First point: Wendigo->LastKnownPlayerLocation (if bHasLastKnownPlayerLocation is true). If false, use pawn's current location as fallback.
         - Generate NumRandomPoints additional points using `UNavigationSystemV1::GetRandomReachablePointInRadius` with SearchRadius. Include `#include "NavigationSystem.h"`.
         - If a random point fails, skip it (don't pad with duplicates).
      5. Set CurrentSearchIndex = 0, TotalSearchTime = 0.
      6. Issue MoveToLocation for SearchPoints[0].
      7. Return Running.
    - `Tick`:
      1. Increment TotalSearchTime. If >= MaxSearchDuration, return Succeeded (search time expired, return to patrol).
      2. If bMoveRequestActive: check GetMoveStatus. If still Moving, return Running. If arrived or idle, set bMoveRequestActive = false.
      3. If not moving: increment TimeAtCurrentPoint (linger). During linger, set focal point to a random offset from current position every ~2 seconds to create "looking around" behavior (similar to STT_PatrolIdle pattern).
      4. When TimeAtCurrentPoint >= LingerDuration: advance CurrentSearchIndex. If more points remain, MoveToLocation the next point and reset TimeAtCurrentPoint. If all points visited, return Succeeded.
      5. Return Running.
    - `ExitState`:
      1. Restore MaxWalkSpeed to AIConstants::WendigoWalkSpeed.
      2. Stop movement, clear focus.
      3. Clear WendigoCharacter's LastKnownPlayerLocation and WitnessedHidingSpot (search complete, slate wiped clean).

    **STT_ReturnToNearestWaypoint** -- navigates to closest patrol waypoint:

    **STT_ReturnToNearestWaypoint.h:**
    - `FSTT_ReturnToNearestWaypointInstanceData` USTRUCT:
      - `bool bMoveRequestActive = false;`
    - `FSTT_ReturnToNearestWaypoint` USTRUCT with `meta = (DisplayName = "Return To Nearest Waypoint")`:
      - `TStateTreeExternalDataHandle<AAIController> ControllerHandle;`
      - UPROPERTY: `float AcceptanceRadius = 50.0f;`

    **STT_ReturnToNearestWaypoint.cpp:**
    - `EnterState`:
      1. Get Wendigo, get PatrolRoute. If no route, return Failed.
      2. Find nearest waypoint: iterate all waypoints using FVector::DistSquared comparison. Use GetWaypoint(i) for world-space positions.
      3. Set Wendigo->CurrentWaypointIndex to the nearest index (so patrol resumes from there).
      4. Set MaxWalkSpeed to AIConstants::WendigoWalkSpeed (patrol speed).
      5. MoveToLocation nearest waypoint position.
      6. Return Running.
    - `Tick`: Check GetMoveStatus. If arrived, return Succeeded. If moving, return Running. If failed, return Failed.
    - `ExitState`: Stop movement if active.

    IMPORTANT: Keep SearchRadius to 600cm max (not larger -- GetRandomReachablePointInRadius degrades with >1500cm). Handle MoveToLocation failure gracefully -- skip to next search point rather than failing the entire task.
  </action>
  <verify>
    Compile cleanly. Verify STT_SearchArea uses NavigationSystem.h include and GetRandomReachablePointInRadius. Verify STT_ReturnToNearestWaypoint uses DistSquared (not Dist -- avoids sqrt).
  </verify>
  <done>
    - STT_SearchArea generates last-known + random NavMesh search points and navigates through them with linger pauses
    - STT_SearchArea respects MaxSearchDuration timeout
    - STT_ReturnToNearestWaypoint finds closest waypoint by DistSquared and navigates there
    - STT_ReturnToNearestWaypoint sets CurrentWaypointIndex for seamless patrol resumption
    - Both tasks follow established FSTT_ pattern and compile cleanly
  </done>
</task>

</tasks>

<verification>
- All three new task files compile cleanly
- STT_ChasePlayer uses MoveToActor (not MoveToLocation) for continuous player tracking
- STT_SearchArea uses GetRandomReachablePointInRadius (not EQS)
- All tasks restore MaxWalkSpeed to AIConstants::WendigoWalkSpeed in ExitState (speed leak prevention)
- All tasks follow the same header structure as existing FSTT_ tasks (includes, Link, EnterState, Tick, ExitState)
</verification>

<success_criteria>
1. STT_ChasePlayer: MoveToActor pursuit with LOS timer, Succeeded on grab range, Failed on LOS timeout
2. STT_SearchArea: last-known + random NavMesh points, linger at each, timeout after MaxSearchDuration
3. STT_ReturnToNearestWaypoint: nearest waypoint by DistSquared, sets CurrentWaypointIndex for patrol resume
4. All three tasks compile cleanly and follow established patterns
</success_criteria>

<output>
After completion, create `.planning/phases/05-monster-behaviors/05-02-SUMMARY.md`
</output>
