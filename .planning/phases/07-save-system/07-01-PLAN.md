---
phase: 07-save-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Source/ProjectWalkingSim/Public/Save/SaveTypes.h
  - Source/ProjectWalkingSim/Public/Save/SereneSaveGame.h
  - Source/ProjectWalkingSim/Private/Save/SereneSaveGame.cpp
  - Source/ProjectWalkingSim/Public/Save/SaveSubsystem.h
  - Source/ProjectWalkingSim/Private/Save/SaveSubsystem.cpp
autonomous: true

must_haves:
  truths:
    - "Save data structures can represent full game state (player position, inventory, door states, destroyed pickups)"
    - "SaveSubsystem can save game state to one of 3 named slots via async disk write"
    - "SaveSubsystem can load game state from a slot and store it as pending data"
    - "SaveSubsystem captures viewport screenshot and compresses to JPEG for slot thumbnail"
    - "SaveSubsystem tracks destroyed level-placed pickups at runtime"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/Save/SaveTypes.h"
      provides: "FSavedDoorState, FSavedDrawerState, FSaveSlotInfo structs"
      contains: "USTRUCT"
    - path: "Source/ProjectWalkingSim/Public/Save/SereneSaveGame.h"
      provides: "USereneSaveGame USaveGame subclass with all save data fields"
      contains: "class USereneSaveGame : public USaveGame"
    - path: "Source/ProjectWalkingSim/Public/Save/SaveSubsystem.h"
      provides: "USaveSubsystem UGameInstanceSubsystem with save/load/screenshot API"
      contains: "class USaveSubsystem : public UGameInstanceSubsystem"
  key_links:
    - from: "SaveSubsystem.cpp"
      to: "UGameplayStatics"
      via: "AsyncSaveGameToSlot, LoadGameFromSlot, DoesSaveGameExist, DeleteGameInSlot"
      pattern: "UGameplayStatics::(AsyncSaveGameToSlot|LoadGameFromSlot)"
    - from: "SaveSubsystem.cpp"
      to: "UGameViewportClient::OnScreenshotCaptured"
      via: "Screenshot delegate binding"
      pattern: "OnScreenshotCaptured"
---

<objective>
Create the save system data foundation: USaveGame subclass with flat struct arrays for all game state, and a UGameInstanceSubsystem that owns save/load orchestration, screenshot capture, and destroyed pickup tracking.

Purpose: All other save system plans depend on these types and this subsystem. This is the core infrastructure that TapeRecorderActor, GameOver, pause menu, and load flow all call into.

Output: SaveTypes.h, SereneSaveGame.h/cpp, SaveSubsystem.h/cpp -- compilable and unit-callable.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-save-system/07-CONTEXT.md
@.planning/phases/07-save-system/07-RESEARCH.md

Key existing files:
@Source/ProjectWalkingSim/Public/Core/SereneGameInstance.h (existing USaveGame pattern for settings)
@Source/ProjectWalkingSim/Public/Inventory/InventoryTypes.h (FInventorySlot struct to save)
@Source/ProjectWalkingSim/Public/Core/SereneLogChannels.h (LogSerene category)
@Source/ProjectWalkingSim/ProjectWalkingSim.Build.cs (may need ImageWrapper module)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Save data types and USaveGame subclass</name>
  <files>
    Source/ProjectWalkingSim/Public/Save/SaveTypes.h
    Source/ProjectWalkingSim/Public/Save/SereneSaveGame.h
    Source/ProjectWalkingSim/Private/Save/SereneSaveGame.cpp
  </files>
  <action>
Create the Save/ directory structure under Public/ and Private/.

**SaveTypes.h** -- Define these USTRUCTs:

1. `FSavedDoorState`: FName DoorId, bool bIsOpen, bool bIsLocked, float CurrentAngle, float OpenDirection. All UPROPERTY().

2. `FSavedDrawerState`: FName DrawerId, bool bIsOpen, float CurrentSlide. All UPROPERTY().

3. `FSaveSlotInfo`: FDateTime Timestamp, TArray<uint8> ScreenshotData (compressed JPEG bytes), int32 ScreenshotWidth, int32 ScreenshotHeight. All UPROPERTY().

**SereneSaveGame.h** -- USereneSaveGame : public USaveGame with:

- int32 SaveVersion = 1 (for future migration)
- FSaveSlotInfo SlotInfo (metadata)
- FVector PlayerLocation
- FRotator PlayerRotation
- TArray<FInventorySlot> InventorySlots (reuses existing FInventorySlot from InventoryTypes.h)
- TArray<FSavedDoorState> DoorStates
- TArray<FSavedDrawerState> DrawerStates
- TArray<FName> DestroyedPickupIds (level-placed pickups that were picked up)

All fields UPROPERTY(). Include InventoryTypes.h for FInventorySlot. The class is a pure data container -- no methods beyond constructor.

**SereneSaveGame.cpp** -- Minimal implementation (just the include, constructor if needed). USereneSaveGame has no complex logic.
  </action>
  <verify>Project compiles with the new Save/ directory and all structs are valid USTRUCTs (check for GENERATED_BODY in each).</verify>
  <done>SaveTypes.h defines FSavedDoorState, FSavedDrawerState, FSaveSlotInfo. SereneSaveGame.h defines USereneSaveGame with all save data fields. All are UPROPERTY-tagged for USaveGame serialization.</done>
</task>

<task type="auto">
  <name>Task 2: SaveSubsystem -- UGameInstanceSubsystem for save/load orchestration</name>
  <files>
    Source/ProjectWalkingSim/Public/Save/SaveSubsystem.h
    Source/ProjectWalkingSim/Private/Save/SaveSubsystem.cpp
    Source/ProjectWalkingSim/ProjectWalkingSim.Build.cs
  </files>
  <action>
**SaveSubsystem.h** -- USaveSubsystem : public UGameInstanceSubsystem with:

Constants:
- static constexpr int32 MaxSlots = 3

Public API (all BlueprintCallable):
- `void SaveToSlot(int32 SlotIndex)` -- Captures screenshot, gathers world state (calls ISaveable::Execute_WriteSaveData on all ISaveable actors via TActorIterator), saves player position + inventory, then calls AsyncSaveGameToSlot. The screenshot capture is async (end-of-frame), so the save flow continues in the OnScreenshotCaptured callback.
- `void LoadFromSlot(int32 SlotIndex)` -- Loads USereneSaveGame from slot, stores in PendingSaveData, calls OpenLevel to restart the map. ApplyPendingSaveData is called by GameMode after level restart.
- `void LoadLatestSave()` -- Finds the most recent slot by comparing FSaveSlotInfo::Timestamp across all 3 slots, then calls LoadFromSlot on that slot.
- `bool HasAnySave() const` -- Returns true if any of the 3 slots has a save file.
- `FSaveSlotInfo GetSlotInfo(int32 SlotIndex) const` -- Loads just the metadata for a slot (for UI display). Returns empty info if slot doesn't exist.
- `void DeleteSlot(int32 SlotIndex)` -- UGameplayStatics::DeleteGameInSlot.
- `bool DoesSaveExist(int32 SlotIndex) const` -- UGameplayStatics::DoesSaveGameExist.
- `int32 GetLatestSlotIndex() const` -- Returns index of most recent save, or -1.

State management:
- `void ApplyPendingSaveData(UWorld* World)` -- Called by GameMode after level reload. Iterates world actors: for each ISaveable actor, calls ISaveable::Execute_ReadSaveData(Actor, PendingSaveData). Destroys pickups whose FName is in DestroyedPickupIds. Sets player position and restores inventory. Clears PendingSaveData after application. Repopulates the DestroyedPickupTracker TSet.
- `bool IsPendingLoad() const` -- Returns PendingSaveData != nullptr.
- `void TrackDestroyedPickup(FName PickupId)` -- Adds to runtime TSet<FName> DestroyedPickupTracker. Called by PickupActor::OnInteract when a level-placed pickup is destroyed.
- `void ClearDestroyedPickupTracker()` -- Empties the tracker (called after applying save data).

Private members:
- `TObjectPtr<USereneSaveGame> PendingSaveData` -- UPROPERTY() to prevent GC.
- `TSet<FName> DestroyedPickupTracker` -- Runtime tracking of destroyed pickups.
- `FString GetSlotName(int32 SlotIndex) const` -- Returns "SaveSlot_0", "SaveSlot_1", "SaveSlot_2".
- Screenshot capture internals: Bind to UGameViewportClient::OnScreenshotCaptured, use FScreenshotRequest::RequestScreenshot(false). In the callback, compress via FImageUtils::CompressImageArray (or use IImageWrapperModule with EImageFormat::JPEG if CompressImageArray format is ambiguous). Store compressed bytes in the pending save's SlotInfo.

**SaveSubsystem.cpp** -- Full implementation of all methods above.

Key implementation notes:
- SaveToSlot flow: (1) create USereneSaveGame, (2) request screenshot, (3) in OnScreenshotCaptured callback: compress pixels, set SlotInfo, gather world state, set player state, call AsyncSaveGameToSlot.
- For gathering world state, iterate with TActorIterator<AActor> and check Implements<USaveable>() before calling Execute_WriteSaveData.
- For player state: get player pawn via UGameplayStatics::GetPlayerPawn(World, 0), cast to ASereneCharacter, read location/rotation, get InventoryComponent->GetSlots().
- ApplyPendingSaveData: iterate TActorIterator<AActor>, check Implements<USaveable>(), call Execute_ReadSaveData. Then handle DestroyedPickupIds and player state.
- For player inventory restore in ApplyPendingSaveData: the inventory must be applied AFTER InventoryComponent::BeginPlay has loaded the ItemRegistry. Use a timer (SetTimerForNextTick or small delay) if needed, or do it in the same frame if BeginPlay order allows it. The safest approach: cache pending inventory in the subsystem, and have the character/controller check for pending save data in its own BeginPlay/PossessedBy.
- Use LogSerene for all log messages.

**Build.cs** -- Check if FImageUtils::CompressImageArray needs any additional module. FImageUtils is in the Engine module (already included). If JPEG compression requires ImageWrapper module, add "ImageWrapper" to PrivateDependencyModuleNames. If FImageUtils suffices alone, skip.

IMPORTANT: Use `FScreenshotRequest::RequestScreenshot(false)` -- the false parameter means "don't show UI notification". The OnScreenshotCaptured delegate signature is `void(int32 Width, int32 Height, const TArray<FColor>& Bitmap)`. After capturing, unbind the delegate (one-shot pattern).

IMPORTANT: AsyncSaveGameToSlot requires a FAsyncSaveGameToSlotDelegate callback. Bind a lambda or member function that logs success/failure.
  </action>
  <verify>Project compiles. Verify SaveSubsystem has all public methods by checking the header. Verify it inherits UGameInstanceSubsystem.</verify>
  <done>USaveSubsystem compiles as a UGameInstanceSubsystem with full save/load/screenshot/tracking API. All methods reference USereneSaveGame. Slot names map to "SaveSlot_0" through "SaveSlot_2".</done>
</task>

</tasks>

<verification>
1. `UnrealBuildTool` compiles the project without errors
2. SaveTypes.h, SereneSaveGame.h, SaveSubsystem.h are in the correct Public/Save/ directory
3. SaveSubsystem inherits UGameInstanceSubsystem (will auto-register on SereneGameInstance)
4. All UPROPERTY fields on USereneSaveGame will be serialized by USaveGame system
5. Screenshot capture uses async pattern (OnScreenshotCaptured delegate, not synchronous ReadPixels)
</verification>

<success_criteria>
- USereneSaveGame contains fields for player position, rotation, inventory, door states, drawer states, destroyed pickups
- USaveSubsystem provides SaveToSlot, LoadFromSlot, LoadLatestSave, HasAnySave, ApplyPendingSaveData, TrackDestroyedPickup
- Screenshot capture compresses to JPEG and stores in SlotInfo
- Project compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-save-system/07-01-SUMMARY.md`
</output>
