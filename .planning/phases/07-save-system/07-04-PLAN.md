---
phase: 07-save-system
plan: 04
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - Source/ProjectWalkingSim/Public/Interaction/TapeRecorderActor.h
  - Source/ProjectWalkingSim/Private/Interaction/TapeRecorderActor.cpp
  - Source/ProjectWalkingSim/Public/Player/HUD/PauseMenuWidget.h
  - Source/ProjectWalkingSim/Private/Player/HUD/PauseMenuWidget.cpp
  - Source/ProjectWalkingSim/Public/Player/SerenePlayerController.h
  - Source/ProjectWalkingSim/Private/Player/SerenePlayerController.cpp
  - Source/ProjectWalkingSim/Public/Player/HUD/SereneHUD.h
  - Source/ProjectWalkingSim/Private/Player/HUD/SereneHUD.cpp
  - Source/ProjectWalkingSim/Public/Player/HUD/SereneHUDWidget.h
autonomous: true

must_haves:
  truths:
    - "Player can interact with a tape recorder in the world to open save slot picker"
    - "Saving at tape recorder captures screenshot and writes game state to selected slot"
    - "Esc opens pause menu with Continue, Load Game, Resume, and Quit options"
    - "Continue in pause menu loads the most recent save"
    - "Load Game in pause menu opens the 3-slot picker in load mode"
    - "Player position is stored as the tape recorder location on save"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/Interaction/TapeRecorderActor.h"
      provides: "Save point actor implementing IInteractable"
      contains: "class ATapeRecorderActor"
    - path: "Source/ProjectWalkingSim/Public/Player/HUD/PauseMenuWidget.h"
      provides: "Pause menu with Continue, Load Game, Resume, Quit"
      contains: "class UPauseMenuWidget"
  key_links:
    - from: "TapeRecorderActor.cpp"
      to: "SaveLoadMenuWidget"
      via: "Opens save slot menu in Save mode"
      pattern: "ESaveLoadMode::Save"
    - from: "PauseMenuWidget.cpp"
      to: "SaveSubsystem::LoadLatestSave"
      via: "Continue button"
      pattern: "LoadLatestSave"
    - from: "PauseMenuWidget.cpp"
      to: "SaveLoadMenuWidget"
      via: "Load Game opens slot picker in Load mode"
      pattern: "ESaveLoadMode::Load"
    - from: "SerenePlayerController.cpp"
      to: "PauseMenuWidget"
      via: "Esc key toggles pause menu"
      pattern: "PauseMenu|TogglePauseMenu"
    - from: "TapeRecorderActor.cpp"
      to: "SaveSubsystem"
      via: "Overrides player save location to tape recorder position"
      pattern: "GetActorLocation"
---

<objective>
Create the TapeRecorderActor (world save point), PauseMenuWidget (Esc menu), and wire everything into the player controller and HUD. This is the final integration plan that makes the save system player-facing.

Purpose: After this plan, the save system is fully functional: players save at tape recorders, die and see Game Over, pause to load saves, and resume play from saved state.

Output: TapeRecorderActor, PauseMenuWidget, Esc input binding, full HUD integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-save-system/07-CONTEXT.md
@.planning/phases/07-save-system/07-RESEARCH.md
@.planning/phases/07-save-system/07-01-SUMMARY.md
@.planning/phases/07-save-system/07-02-SUMMARY.md
@.planning/phases/07-save-system/07-03-SUMMARY.md

Key files from prior plans:
@Source/ProjectWalkingSim/Public/Save/SaveSubsystem.h (from 07-01)
@Source/ProjectWalkingSim/Public/Player/HUD/SaveLoadMenuWidget.h (from 07-03)
@Source/ProjectWalkingSim/Public/Player/HUD/GameOverWidget.h (from 07-03)

Key files to modify:
@Source/ProjectWalkingSim/Public/Player/SerenePlayerController.h
@Source/ProjectWalkingSim/Private/Player/SerenePlayerController.cpp
@Source/ProjectWalkingSim/Public/Player/HUD/SereneHUD.h
@Source/ProjectWalkingSim/Private/Player/HUD/SereneHUD.cpp
@Source/ProjectWalkingSim/Public/Player/HUD/SereneHUDWidget.h
@Source/ProjectWalkingSim/Public/Interaction/InteractableBase.h (pattern reference)

Existing patterns:
@Source/ProjectWalkingSim/Public/Interaction/DoorActor.h (IInteractable pattern)
@Source/ProjectWalkingSim/Public/Hiding/HidingComponent.h (state checking)
</context>

<tasks>

<task type="auto">
  <name>Task 1: TapeRecorderActor -- save point interactable</name>
  <files>
    Source/ProjectWalkingSim/Public/Interaction/TapeRecorderActor.h
    Source/ProjectWalkingSim/Private/Interaction/TapeRecorderActor.cpp
  </files>
  <action>
**TapeRecorderActor.h** -- ATapeRecorderActor : public AInteractableBase

Inherits from AInteractableBase (same base as DoorActor, PickupActor). This is the world-placed tape recorder that serves as a save point. Interacting opens the save slot picker.

Properties:
- `UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Save") TObjectPtr<USoundBase> SaveSound` -- Sound played when save starts (tape rolling). Assigned in Blueprint.
- `UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Save") float SaveAnimDuration = 1.5f` -- Duration of save feedback before the slot picker opens. Can be 0 to skip.
- `UPROPERTY(EditDefaultsOnly, Category = "Save") TSubclassOf<USaveLoadMenuWidget> SaveMenuWidgetClass` -- Blueprint subclass of SaveLoadMenuWidget. Assigned in BP subclass.

Override IInteractable methods:
- `CanInteract_Implementation(AActor* Interactor)`: Return true only if: (1) bCanBeInteracted is true, (2) player is not hiding (check HidingComponent->GetHidingState() == EHidingState::Free), (3) no save menu is already open. Get HidingComponent from the player character.
- `GetInteractionText_Implementation()`: Return FText "Record" (the detective is recording case notes on the tape recorder).
- `OnInteract_Implementation(AActor* Interactor)`:
  1. Play SaveSound at actor location (UGameplayStatics::PlaySoundAtLocation).
  2. Create the SaveLoadMenuWidget from SaveMenuWidgetClass, add to viewport.
  3. Call widget->OpenMenu(ESaveLoadMode::Save).
  4. Set player input mode to Game+UI (FInputModeGameAndUI) so the player can click slots.
  5. Show mouse cursor.
  6. Bind widget->OnMenuClosed to HandleSaveMenuClosed.
  7. CRITICAL: Before opening the menu, tell the SaveSubsystem what player position to use for this save. Add a method or set a pending location on SaveSubsystem: `SaveSubsystem->SetPendingSaveLocation(GetActorLocation(), GetActorRotation())`. The SaveSubsystem's SaveToSlot will use this pending location instead of the player's current position. This ensures the player loads at the tape recorder, not wherever they were standing. After the save completes or menu closes, clear the pending location.

Private:
- `UPROPERTY() TObjectPtr<USaveLoadMenuWidget> SaveMenuInstance` -- Live widget instance.
- `void HandleSaveMenuClosed()` -- Hide cursor, restore input mode to Game Only, remove widget from viewport, clear SaveMenuInstance. Clear pending save location on SaveSubsystem.

**TapeRecorderActor.cpp** -- Full implementation.

Constructor: Set InteractionText to NSLOCTEXT("Interaction", "TapeRecorder", "Record"). Set InteractionTag if desired (optional).

IMPORTANT: The SaveSubsystem needs a way to accept the tape recorder's location as the save position. Add two methods to SaveSubsystem (this requires a small modification to SaveSubsystem.h/cpp):
- `void SetPendingSaveLocation(const FVector& Location, const FRotator& Rotation)` -- Stores location/rotation.
- `void ClearPendingSaveLocation()` -- Clears.
- In SaveToSlot: use PendingSaveLocation if set, otherwise use player's current location. Add FVector PendingSaveLocation and FRotator PendingSaveRotation and bool bHasPendingSaveLocation to private members.

Since SaveSubsystem.h is from Plan 01 and should not be modified by other plans in parallel execution, but this is Wave 3 (after Plan 01 is complete), it is safe to modify SaveSubsystem.h/cpp here. Add these files to the task scope.

Additional files:
- Source/ProjectWalkingSim/Public/Save/SaveSubsystem.h (add pending location API)
- Source/ProjectWalkingSim/Private/Save/SaveSubsystem.cpp (implement pending location methods, use in SaveToSlot)
  </action>
  <verify>Project compiles. TapeRecorderActor inherits AInteractableBase and opens SaveLoadMenuWidget in Save mode. SaveSubsystem has SetPendingSaveLocation/ClearPendingSaveLocation. TapeRecorderActor sets pending location in OnInteract and clears it in HandleSaveMenuClosed.</verify>
  <done>TapeRecorderActor opens save slot picker on interaction. Player location saved as tape recorder position. Save sound plays. Menu closes cleanly with input mode restored.</done>
</task>

<task type="auto">
  <name>Task 2: PauseMenuWidget + Esc binding + HUD integration</name>
  <files>
    Source/ProjectWalkingSim/Public/Player/HUD/PauseMenuWidget.h
    Source/ProjectWalkingSim/Private/Player/HUD/PauseMenuWidget.cpp
    Source/ProjectWalkingSim/Public/Player/SerenePlayerController.h
    Source/ProjectWalkingSim/Private/Player/SerenePlayerController.cpp
    Source/ProjectWalkingSim/Public/Player/HUD/SereneHUD.h
    Source/ProjectWalkingSim/Private/Player/HUD/SereneHUD.cpp
    Source/ProjectWalkingSim/Public/Player/HUD/SereneHUDWidget.h
  </files>
  <action>
**PauseMenuWidget.h** -- UPauseMenuWidget : public UUserWidget

Pause menu opened by Esc. Contains: Continue (load latest), Load Game (open slot picker), Resume (close menu), Quit (exit game).

BindWidget members:
- `TObjectPtr<UTextBlock> PauseTitle` -- "PAUSED".
- `TObjectPtr<UButton> ContinueButton` -- Loads latest save.
- `TObjectPtr<UButton> LoadGameButton` -- Opens SaveLoadMenuWidget in Load mode.
- `TObjectPtr<UButton> ResumeButton` -- Closes pause menu, resumes game.
- `TObjectPtr<UButton> QuitButton` -- Exits to desktop.

Properties:
- `UPROPERTY(EditDefaultsOnly, Category = "Pause") TSubclassOf<USaveLoadMenuWidget> LoadMenuWidgetClass` -- Blueprint class for the load menu.

Override NativeConstruct:
- Bind ContinueButton OnClicked -> HandleContinueClicked.
- Bind LoadGameButton OnClicked -> HandleLoadGameClicked.
- Bind ResumeButton OnClicked -> HandleResumeClicked.
- Bind QuitButton OnClicked -> HandleQuitClicked.
- Check SaveSubsystem->HasAnySave(). If false, disable ContinueButton and LoadGameButton (SetIsEnabled(false)) since there's nothing to load.

Delegate:
- `FOnMenuClosed OnPauseMenuClosed` -- Broadcast when Resume is clicked or menu should close.

Private:
- `UPROPERTY() TObjectPtr<USaveLoadMenuWidget> LoadMenuInstance`
- `HandleContinueClicked()`: Call SaveSubsystem->LoadLatestSave(). (This triggers OpenLevel which will handle everything.)
- `HandleLoadGameClicked()`: Create LoadMenuWidgetClass instance, add to viewport, call OpenMenu(ESaveLoadMode::Load). Hide the pause menu (SetVisibility Collapsed) while load menu is open. Bind LoadMenuInstance->OnMenuClosed to HandleLoadMenuClosed.
- `HandleResumeClicked()`: Broadcast OnPauseMenuClosed.
- `HandleQuitClicked()`: UKismetSystemLibrary::QuitGame.
- `HandleLoadMenuClosed()`: Show pause menu again (SetVisibility Visible). Remove load menu from viewport.

**PauseMenuWidget.cpp** -- Full implementation.

**SerenePlayerController.h** -- Add:
- `UPROPERTY(EditDefaultsOnly, Category = "Input") TObjectPtr<UInputAction> PauseAction` -- Esc key input action.
- `UPROPERTY(EditDefaultsOnly, Category = "UI") TSubclassOf<UPauseMenuWidget> PauseMenuWidgetClass` -- Blueprint pause menu class.
- Private: `UPROPERTY() TObjectPtr<UPauseMenuWidget> PauseMenuInstance`
- Private: `bool bIsPaused = false`
- Private: `void HandlePause(const FInputActionValue& Value)` -- Toggles pause menu.
- Private: `void HandlePauseMenuClosed()` -- Hides pause, restores input.
- Public: `void TogglePauseMenu()` -- Can be called externally if needed.

**SerenePlayerController.cpp** -- Implement:
- In `SetupInputComponent`: Bind PauseAction (Started trigger) to HandlePause.
- `HandlePause`: Call TogglePauseMenu().
- `TogglePauseMenu()`:
  - If bIsPaused: close pause menu. Set bIsPaused = false. Remove widget from viewport or set Collapsed. Restore input mode to Game Only. Hide cursor. Call UGameplayStatics::SetGamePaused(GetWorld(), false).
  - If !bIsPaused: open pause menu. Set bIsPaused = true. Create widget if not exists, add to viewport. Show cursor. Set input mode to Game+UI. Call UGameplayStatics::SetGamePaused(GetWorld(), true). Bind OnPauseMenuClosed delegate.
- `HandlePauseMenuClosed()`: Same as closing in TogglePauseMenu (unpause, hide cursor, restore input).

IMPORTANT: Do NOT open pause menu if: inventory is open (bIsInventoryOpen is true), player is hiding, or Game Over is showing. Check these conditions in TogglePauseMenu before opening.

IMPORTANT: The Esc key also needs to close inventory if it's open. Modify HandlePause: if bIsInventoryOpen, call CloseInventory() instead of toggling pause.

**SereneHUD.h** -- No changes needed for this plan. The pause menu is managed by the PlayerController directly (same as how inventory is managed). However, if you want consistency, you could route through SereneHUD. For simplicity, manage pause menu on PlayerController since it owns input mode.

Actually, for consistency with the existing pattern (SereneHUD manages ShowInventory/HideInventory), add pause menu management to SereneHUD:
- `void ShowPauseMenu()` / `void HidePauseMenu()` -- But the GamePaused state is on the controller...

DECISION: Keep pause menu on PlayerController (it owns input mode and pause state). This matches common UE patterns where the controller manages game state UI. SereneHUD manages gameplay HUD (stamina, interaction, inventory).

**SereneHUD.h / SereneHUDWidget.h** -- No changes needed. The pause menu is a standalone widget managed by the controller, not a child of the HUD widget.

Wait -- check if SereneHUD needs any changes. The Game Over widget is created by GameMode (Plan 02), pause menu by PlayerController. SaveLoadMenu by TapeRecorderActor and PauseMenuWidget. All are standalone viewport widgets, not HUD children. This is correct -- they overlay the HUD rather than being part of it.

**SereneHUD.h/cpp and SereneHUDWidget.h** -- Actually, we may not need to modify these at all for this plan. Remove them from the task if no changes are needed.

REVISED: Only modify SerenePlayerController and create PauseMenuWidget + TapeRecorderActor. Remove SereneHUD/SereneHUDWidget from this task's file list.

However -- keep SereneHUD.h in the plan's files_modified list in case we need to add a helper to check if Game Over is showing (to prevent pause during Game Over). If GameOverWidget is managed by GameMode, the controller can check GameMode for that state. Add a `bool IsGameOver() const` on SereneGameMode (returns GameOverWidgetInstance != nullptr). The controller queries this.

ADDITIONAL CHANGE to SereneGameMode.h/cpp (from Plan 02): Add `bool IsGameOver() const { return GameOverWidgetInstance != nullptr; }`. Since Plan 02 already modifies these files and Plan 02 is Wave 2 (completed before this Wave 3 plan), this is safe. Modify SereneGameMode.h to add the IsGameOver method.

Files for this task:
- PauseMenuWidget.h/cpp (new)
- SerenePlayerController.h/cpp (modify -- add Esc binding, pause toggle)
- SereneGameMode.h (modify -- add IsGameOver, only if not already added by Plan 02)
  </action>
  <verify>Project compiles. SerenePlayerController has PauseAction binding and TogglePauseMenu method. PauseMenuWidget has Continue/LoadGame/Resume/Quit buttons. Esc key opens pause menu. Esc while inventory open closes inventory instead.</verify>
  <done>PauseMenuWidget provides full pause menu with Continue, Load Game, Resume, Quit. Esc key toggles pause. Pause prevented during inventory, hiding, or Game Over. Load Game opens SaveLoadMenuWidget in Load mode.</done>
</task>

</tasks>

<verification>
1. Project compiles without errors
2. TapeRecorderActor inherits AInteractableBase and shows "Record" interaction text
3. Interacting with tape recorder opens SaveLoadMenuWidget in Save mode
4. Player save location is set to tape recorder position (not player position)
5. Esc opens pause menu with 4 working buttons
6. Continue loads most recent save (or disabled if no saves)
7. Load Game opens 3-slot picker in Load mode
8. Resume unpauses and restores input
9. Quit exits game
10. Esc closes inventory if inventory is open
11. Pause is blocked during Game Over state
</verification>

<success_criteria>
- Full save flow: interact with tape recorder -> select slot -> game saves (screenshot + state) -> menu closes
- Full load flow via pause: Esc -> Load Game -> select occupied slot -> level reloads with saved state
- Full load flow via continue: Esc -> Continue -> level reloads with latest save
- Death flow: Wendigo grabs -> Game Over screen -> Load Last Save -> level reloads with saved state
- Death with no saves: Game Over -> Restart -> fresh level start
- All UI interactions are clean (cursor, input mode, widget lifecycle)
</success_criteria>

<output>
After completion, create `.planning/phases/07-save-system/07-04-SUMMARY.md`
</output>
