---
phase: 07-save-system
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - Source/ProjectWalkingSim/Public/Interaction/SaveableInterface.h
  - Source/ProjectWalkingSim/Private/Interaction/SaveableInterface.cpp
  - Source/ProjectWalkingSim/Public/Interaction/DoorActor.h
  - Source/ProjectWalkingSim/Private/Interaction/DoorActor.cpp
  - Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
  - Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
  - Source/ProjectWalkingSim/Public/Interaction/DrawerActor.h
  - Source/ProjectWalkingSim/Private/Interaction/DrawerActor.cpp
  - Source/ProjectWalkingSim/Public/Core/SereneGameMode.h
  - Source/ProjectWalkingSim/Private/Core/SereneGameMode.cpp
  - Source/ProjectWalkingSim/Public/AI/Tasks/STT_GrabAttack.h
  - Source/ProjectWalkingSim/Private/AI/Tasks/STT_GrabAttack.cpp
  - Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h
  - Source/ProjectWalkingSim/Private/Inventory/InventoryComponent.cpp
autonomous: true

must_haves:
  truths:
    - "DoorActor writes and reads its open/closed/locked/angle state to/from USereneSaveGame"
    - "PickupActor notifies SaveSubsystem when destroyed on pickup so the ID is tracked"
    - "DrawerActor writes and reads its open/closed/slide state to/from USereneSaveGame"
    - "Death triggers a Game Over screen instead of RestartLevel"
    - "GameMode calls ApplyPendingSaveData on SaveSubsystem after level restart when a load is pending"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/Interaction/SaveableInterface.h"
      provides: "Expanded ISaveable with USereneSaveGame* parameter"
      contains: "USereneSaveGame"
    - path: "Source/ProjectWalkingSim/Public/Core/SereneGameMode.h"
      provides: "OnPlayerDeath method and ApplyPendingSaveData hook"
      contains: "OnPlayerDeath"
    - path: "Source/ProjectWalkingSim/Private/AI/Tasks/STT_GrabAttack.cpp"
      provides: "Death via GameMode delegate instead of RestartLevel"
      contains: "OnPlayerDeath"
  key_links:
    - from: "DoorActor.cpp"
      to: "SereneSaveGame"
      via: "ISaveable::WriteSaveData/ReadSaveData"
      pattern: "Execute_WriteSaveData|Execute_ReadSaveData"
    - from: "PickupActor.cpp"
      to: "SaveSubsystem"
      via: "TrackDestroyedPickup call on pickup"
      pattern: "TrackDestroyedPickup"
    - from: "STT_GrabAttack.cpp"
      to: "SereneGameMode::OnPlayerDeath"
      via: "GameMode cast and method call"
      pattern: "OnPlayerDeath"
    - from: "SereneGameMode.cpp"
      to: "SaveSubsystem::ApplyPendingSaveData"
      via: "Post-init hook"
      pattern: "ApplyPendingSaveData"
---

<objective>
Implement ISaveable on all world-state actors (doors, pickups, drawers), wire the death system to show Game Over instead of restarting, and hook GameMode to apply pending save data after level reload.

Purpose: This plan makes the save system functional end-to-end. Actors can write/read their state, death flows through the Game Over screen (which Plan 03 creates the widget for), and level reloads correctly restore saved state.

Output: Working ISaveable implementations on 3 actor types, death event pipeline, and GameMode load-flow hook.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-save-system/07-CONTEXT.md
@.planning/phases/07-save-system/07-RESEARCH.md
@.planning/phases/07-save-system/07-01-SUMMARY.md

Key existing files to modify:
@Source/ProjectWalkingSim/Public/Interaction/SaveableInterface.h
@Source/ProjectWalkingSim/Public/Interaction/DoorActor.h
@Source/ProjectWalkingSim/Private/Interaction/DoorActor.cpp
@Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
@Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
@Source/ProjectWalkingSim/Public/Interaction/DrawerActor.h
@Source/ProjectWalkingSim/Private/Interaction/DrawerActor.cpp
@Source/ProjectWalkingSim/Public/Core/SereneGameMode.h
@Source/ProjectWalkingSim/Private/Core/SereneGameMode.cpp
@Source/ProjectWalkingSim/Public/AI/Tasks/STT_GrabAttack.h
@Source/ProjectWalkingSim/Private/AI/Tasks/STT_GrabAttack.cpp
@Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h
@Source/ProjectWalkingSim/Private/Inventory/InventoryComponent.cpp
@Source/ProjectWalkingSim/Public/Save/SereneSaveGame.h (from 07-01)
@Source/ProjectWalkingSim/Public/Save/SaveSubsystem.h (from 07-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand ISaveable interface and implement on DoorActor, PickupActor, DrawerActor</name>
  <files>
    Source/ProjectWalkingSim/Public/Interaction/SaveableInterface.h
    Source/ProjectWalkingSim/Private/Interaction/SaveableInterface.cpp
    Source/ProjectWalkingSim/Public/Interaction/DoorActor.h
    Source/ProjectWalkingSim/Private/Interaction/DoorActor.cpp
    Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
    Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
    Source/ProjectWalkingSim/Public/Interaction/DrawerActor.h
    Source/ProjectWalkingSim/Private/Interaction/DrawerActor.cpp
  </files>
  <action>
**SaveableInterface.h** -- Replace the existing stub with expanded signatures:

```cpp
class ISaveable
{
    GENERATED_BODY()
public:
    /** Return a unique, stable identifier for this actor instance. */
    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Save")
    FName GetSaveId() const;

    /** Write this actor's state into the save game object. */
    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Save")
    void WriteSaveData(USereneSaveGame* SaveGame);

    /** Restore this actor's state from saved data. */
    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Save")
    void ReadSaveData(USereneSaveGame* SaveGame);
};
```

Key changes from stub:
- GetSaveId returns FName (was FString) -- FName matches actor GetFName() and door/pickup ID patterns.
- WriteSaveData/ReadSaveData now accept USereneSaveGame* parameter.
- Forward declare USereneSaveGame in the header (class USereneSaveGame;).

IMPORTANT: Before changing GetSaveId from FString to FName, verify no Blueprint classes implement ISaveable. Search the Content/ directory for Blueprint assets that reference SaveableInterface. If any Blueprint implementors exist, the signature change requires updating those Blueprints too. In this project, ISaveable is only implemented in C++ (DoorActor, PickupActor, DrawerActor), so the FName change is safe -- but confirm with a quick grep/search.

**SaveableInterface.cpp** -- Still minimal (just the include). The USaveable UInterface UObject boilerplate is auto-generated.

**DoorActor.h** -- Add ISaveable to the inheritance list (already has IInteractable via AInteractableBase). Add:
- `public ISaveable` to class declaration (multiple inheritance with IInteractable is fine -- both are UInterfaces)
- Override declarations: GetSaveId, WriteSaveData, ReadSaveData

Note: DoorActor already has bIsOpen, bIsLocked, CurrentAngle, TargetAngle, OpenDirection as protected members. The ISaveable methods can access them directly.

**DoorActor.cpp** -- Implement:
- `GetSaveId_Implementation`: return GetFName() (stable for level-placed actors).
- `WriteSaveData_Implementation(USereneSaveGame* SaveGame)`: Create FSavedDoorState, populate from bIsOpen/bIsLocked/CurrentAngle/OpenDirection, add to SaveGame->DoorStates.
- `ReadSaveData_Implementation(USereneSaveGame* SaveGame)`: Find matching FSavedDoorState by FName in SaveGame->DoorStates. Restore bIsOpen, bIsLocked, CurrentAngle, OpenDirection. Set TargetAngle = bIsOpen ? (OpenAngle * OpenDirection) : 0.0f. Apply DoorMesh rotation immediately (no interpolation on load -- snap to saved position).

Include SaveableInterface.h and SereneSaveGame.h.

**PickupActor.h** -- Add ISaveable inheritance. Override GetSaveId, WriteSaveData, ReadSaveData.

**PickupActor.cpp** -- Implement:
- `GetSaveId_Implementation`: return GetFName().
- `WriteSaveData_Implementation`: PickupActors don't write individual state -- their destruction is tracked by SaveSubsystem::DestroyedPickupTracker. This method can be a no-op or add GetFName() to the save's DestroyedPickupIds if not already there (but the subsystem handles this).
- `ReadSaveData_Implementation`: No-op -- destruction is handled by SaveSubsystem::ApplyPendingSaveData which destroys pickups by FName.
- **Critical addition to OnInteract_Implementation**: After the existing `Destroy()` call (when bDestroyOnPickup is true), first call `USaveSubsystem::TrackDestroyedPickup(GetFName())`. Get the subsystem via `GetGameInstance()->GetSubsystem<USaveSubsystem>()`. Check for null GameInstance and null subsystem.

**DrawerActor.h** -- Add ISaveable inheritance. Override GetSaveId, WriteSaveData, ReadSaveData. The ISaveable implementations are member functions of DrawerActor itself, so they can access private members directly -- no need to change access specifiers.

**DrawerActor.cpp** -- Implement:
- `GetSaveId_Implementation`: return GetFName().
- `WriteSaveData_Implementation`: Create FSavedDrawerState, populate from bIsOpen/CurrentSlide, add to SaveGame->DrawerStates.
- `ReadSaveData_Implementation`: Find matching FSavedDrawerState by FName. Restore bIsOpen and CurrentSlide. Snap DrawerMesh to saved position: compute relative location from DrawerInitialLocation + forward * CurrentSlide.

NOTE on DrawerInitialLocation: This member is populated in the DrawerActor constructor body via `DrawerMesh->GetRelativeLocation()`, NOT at declaration time. It captures the mesh component's initial relative location after the constructor sets up default sub-objects. On level reload, the actor is freshly spawned, so DrawerInitialLocation will hold the correct default position before ReadSaveData is called. ReadSaveData must set DrawerMesh relative location to `DrawerInitialLocation + ActorForwardVector * CurrentSlide`.
  </action>
  <verify>Project compiles. Verify DoorActor, PickupActor, DrawerActor all implement ISaveable (grep for "public ISaveable" in their headers). Verify PickupActor::OnInteract calls TrackDestroyedPickup before Destroy().</verify>
  <done>ISaveable interface expanded with USereneSaveGame* parameter. DoorActor saves/restores open/closed/locked/angle. PickupActor tracks destruction via SaveSubsystem. DrawerActor saves/restores open/closed/slide.</done>
</task>

<task type="auto">
  <name>Task 2: Death system + GameMode load flow + GrabAttack replacement + inventory restore</name>
  <files>
    Source/ProjectWalkingSim/Public/Core/SereneGameMode.h
    Source/ProjectWalkingSim/Private/Core/SereneGameMode.cpp
    Source/ProjectWalkingSim/Public/AI/Tasks/STT_GrabAttack.h
    Source/ProjectWalkingSim/Private/AI/Tasks/STT_GrabAttack.cpp
    Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h
    Source/ProjectWalkingSim/Private/Inventory/InventoryComponent.cpp
  </files>
  <action>
**SereneGameMode.h** -- Expand from minimal constructor-only class:

Add public methods:
- `void OnPlayerDeath()` -- Called when player dies (Wendigo grab completes). Creates UGameOverWidget (class reference via TSubclassOf UPROPERTY EditDefaultsOnly), adds to viewport, enables mouse cursor, sets input mode to UI Only.
- `virtual void InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage) override` -- After Super::InitGame, check if SaveSubsystem has pending load data. If so, register a delegate with GetWorld()->OnActorsInitialized to call OnActorsReady.

Add protected members:
- `UPROPERTY(EditDefaultsOnly, Category = "UI") TSubclassOf<UUserWidget> GameOverWidgetClass` -- Blueprint subclass of GameOverWidget assigned here.
- `UPROPERTY() TObjectPtr<UUserWidget> GameOverWidgetInstance` -- Live instance.

Add private method:
- `void OnActorsReady(const FActorsInitializedParams& Params)` -- Called by OnActorsInitialized delegate. Gets SaveSubsystem, calls ApplyPendingSaveData(GetWorld()). This ensures all actors have been spawned and their constructors/BeginPlay have run.

**SereneGameMode.cpp** -- Implement:
- Constructor: keep existing defaults.
- `InitGame`: Call Super::InitGame. Get SaveSubsystem via `GetGameInstance()->GetSubsystem<USaveSubsystem>()`. If `SaveSubsystem && SaveSubsystem->IsPendingLoad()`, bind to `GetWorld()->OnActorsInitialized.AddUObject(this, &ASereneGameMode::OnActorsReady)`.
- `OnActorsReady`: Get SaveSubsystem, call `ApplyPendingSaveData(GetWorld())`. Log success.
- `OnPlayerDeath`: Create GameOverWidget from class, add to viewport, set input mode.

Include SaveSubsystem.h, GameOverWidget.h (forward declare in header).

**InventoryComponent.h** -- Add a single public method:
```cpp
/** Restore inventory from saved data. Replaces all current slots. Broadcasts OnInventoryChanged. */
UFUNCTION(BlueprintCallable, Category = "Inventory")
void RestoreSavedInventory(const TArray<FInventorySlot>& SavedSlots);
```

**InventoryComponent.cpp** -- Implement:
```cpp
void UInventoryComponent::RestoreSavedInventory(const TArray<FInventorySlot>& SavedSlots)
{
    Slots = SavedSlots;
    Slots.SetNum(MaxSlots); // Ensure exactly 8 slots
    OnInventoryChanged.Broadcast();
}
```

This method is called by SaveSubsystem::ApplyPendingSaveData to restore the player's inventory after a load.

**STT_GrabAttack.cpp** -- Replace the `PlayerController->ConsoleCommand(TEXT("RestartLevel"))` in Tick() with:
```cpp
if (ASereneGameMode* GM = Cast<ASereneGameMode>(World->GetAuthGameMode()))
{
    GM->OnPlayerDeath();
}
```
Include SereneGameMode.h. Remove the RestartLevel console command entirely.

**STT_GrabAttack.h** -- No changes needed (the Tick signature doesn't change).
  </action>
  <verify>Project compiles. Verify STT_GrabAttack.cpp no longer contains "RestartLevel". Verify SereneGameMode.h declares OnPlayerDeath and InitGame override. Verify InventoryComponent.h declares RestoreSavedInventory.</verify>
  <done>Death triggers GameMode::OnPlayerDeath instead of RestartLevel. GameMode hooks into level init to apply pending save data. InventoryComponent has RestoreSavedInventory for load flow. Full death-to-reload pipeline is wired.</done>
</task>

</tasks>

<verification>
1. Project compiles without errors
2. `grep -r "RestartLevel" Source/` returns no results in STT_GrabAttack files
3. DoorActor, DrawerActor implement ISaveable (WriteSaveData/ReadSaveData with USereneSaveGame*)
4. PickupActor calls SaveSubsystem::TrackDestroyedPickup in OnInteract before Destroy
5. SereneGameMode::InitGame checks for pending load and binds OnActorsInitialized
6. SereneGameMode::OnPlayerDeath creates Game Over widget
7. InventoryComponent::RestoreSavedInventory exists and broadcasts OnInventoryChanged
</verification>

<success_criteria>
- ISaveable interface works with USereneSaveGame* parameter on all 3 actor types
- Death goes through OnPlayerDeath instead of RestartLevel
- Level reload triggers ApplyPendingSaveData which restores doors, drawers, destroys pickups, restores player position and inventory
- PickupActor destruction is tracked at runtime via SaveSubsystem
- InventoryComponent can restore saved inventory via RestoreSavedInventory
</success_criteria>

<output>
After completion, create `.planning/phases/07-save-system/07-02-SUMMARY.md`
</output>
