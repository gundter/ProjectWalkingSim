---
phase: 07-save-system
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - Source/ProjectWalkingSim/Public/Interaction/SaveableInterface.h
  - Source/ProjectWalkingSim/Private/Interaction/SaveableInterface.cpp
  - Source/ProjectWalkingSim/Public/Interaction/DoorActor.h
  - Source/ProjectWalkingSim/Private/Interaction/DoorActor.cpp
  - Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
  - Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
  - Source/ProjectWalkingSim/Public/Interaction/DrawerActor.h
  - Source/ProjectWalkingSim/Private/Interaction/DrawerActor.cpp
  - Source/ProjectWalkingSim/Public/Core/SereneGameMode.h
  - Source/ProjectWalkingSim/Private/Core/SereneGameMode.cpp
  - Source/ProjectWalkingSim/Public/AI/Tasks/STT_GrabAttack.h
  - Source/ProjectWalkingSim/Private/AI/Tasks/STT_GrabAttack.cpp
autonomous: true

must_haves:
  truths:
    - "DoorActor writes and reads its open/closed/locked/angle state to/from USereneSaveGame"
    - "PickupActor notifies SaveSubsystem when destroyed on pickup so the ID is tracked"
    - "DrawerActor writes and reads its open/closed/slide state to/from USereneSaveGame"
    - "Death triggers a Game Over screen instead of RestartLevel"
    - "GameMode calls ApplyPendingSaveData on SaveSubsystem after level restart when a load is pending"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/Interaction/SaveableInterface.h"
      provides: "Expanded ISaveable with USereneSaveGame* parameter"
      contains: "USereneSaveGame"
    - path: "Source/ProjectWalkingSim/Public/Core/SereneGameMode.h"
      provides: "OnPlayerDeath method and ApplyPendingSaveData hook"
      contains: "OnPlayerDeath"
    - path: "Source/ProjectWalkingSim/Private/AI/Tasks/STT_GrabAttack.cpp"
      provides: "Death via GameMode delegate instead of RestartLevel"
      contains: "OnPlayerDeath"
  key_links:
    - from: "DoorActor.cpp"
      to: "SereneSaveGame"
      via: "ISaveable::WriteSaveData/ReadSaveData"
      pattern: "Execute_WriteSaveData|Execute_ReadSaveData"
    - from: "PickupActor.cpp"
      to: "SaveSubsystem"
      via: "TrackDestroyedPickup call on pickup"
      pattern: "TrackDestroyedPickup"
    - from: "STT_GrabAttack.cpp"
      to: "SereneGameMode::OnPlayerDeath"
      via: "GameMode cast and method call"
      pattern: "OnPlayerDeath"
    - from: "SereneGameMode.cpp"
      to: "SaveSubsystem::ApplyPendingSaveData"
      via: "Post-init hook"
      pattern: "ApplyPendingSaveData"
---

<objective>
Implement ISaveable on all world-state actors (doors, pickups, drawers), wire the death system to show Game Over instead of restarting, and hook GameMode to apply pending save data after level reload.

Purpose: This plan makes the save system functional end-to-end. Actors can write/read their state, death flows through the Game Over screen (which Plan 03 creates the widget for), and level reloads correctly restore saved state.

Output: Working ISaveable implementations on 3 actor types, death event pipeline, and GameMode load-flow hook.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-save-system/07-CONTEXT.md
@.planning/phases/07-save-system/07-RESEARCH.md
@.planning/phases/07-save-system/07-01-SUMMARY.md

Key existing files to modify:
@Source/ProjectWalkingSim/Public/Interaction/SaveableInterface.h
@Source/ProjectWalkingSim/Public/Interaction/DoorActor.h
@Source/ProjectWalkingSim/Private/Interaction/DoorActor.cpp
@Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
@Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
@Source/ProjectWalkingSim/Public/Interaction/DrawerActor.h
@Source/ProjectWalkingSim/Private/Interaction/DrawerActor.cpp
@Source/ProjectWalkingSim/Public/Core/SereneGameMode.h
@Source/ProjectWalkingSim/Private/Core/SereneGameMode.cpp
@Source/ProjectWalkingSim/Public/AI/Tasks/STT_GrabAttack.h
@Source/ProjectWalkingSim/Private/AI/Tasks/STT_GrabAttack.cpp
@Source/ProjectWalkingSim/Public/Save/SereneSaveGame.h (from 07-01)
@Source/ProjectWalkingSim/Public/Save/SaveSubsystem.h (from 07-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand ISaveable interface and implement on DoorActor, PickupActor, DrawerActor</name>
  <files>
    Source/ProjectWalkingSim/Public/Interaction/SaveableInterface.h
    Source/ProjectWalkingSim/Private/Interaction/SaveableInterface.cpp
    Source/ProjectWalkingSim/Public/Interaction/DoorActor.h
    Source/ProjectWalkingSim/Private/Interaction/DoorActor.cpp
    Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
    Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
    Source/ProjectWalkingSim/Public/Interaction/DrawerActor.h
    Source/ProjectWalkingSim/Private/Interaction/DrawerActor.cpp
  </files>
  <action>
**SaveableInterface.h** -- Replace the existing stub with expanded signatures:

```cpp
class ISaveable
{
    GENERATED_BODY()
public:
    /** Return a unique, stable identifier for this actor instance. */
    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Save")
    FName GetSaveId() const;

    /** Write this actor's state into the save game object. */
    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Save")
    void WriteSaveData(USereneSaveGame* SaveGame);

    /** Restore this actor's state from saved data. */
    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Save")
    void ReadSaveData(USereneSaveGame* SaveGame);
};
```

Key changes from stub:
- GetSaveId returns FName (was FString) -- FName matches actor GetFName() and door/pickup ID patterns.
- WriteSaveData/ReadSaveData now accept USereneSaveGame* parameter.
- Forward declare USereneSaveGame in the header (class USereneSaveGame;).

**SaveableInterface.cpp** -- Still minimal (just the include). The USaveable UInterface UObject boilerplate is auto-generated.

**DoorActor.h** -- Add ISaveable to the inheritance list (already has IInteractable via AInteractableBase). Add:
- `public ISaveable` to class declaration (multiple inheritance with IInteractable is fine -- both are UInterfaces)
- Override declarations: GetSaveId, WriteSaveData, ReadSaveData

Note: DoorActor already has bIsOpen, bIsLocked, CurrentAngle, TargetAngle, OpenDirection as protected members. The ISaveable methods can access them directly.

**DoorActor.cpp** -- Implement:
- `GetSaveId_Implementation`: return GetFName() (stable for level-placed actors).
- `WriteSaveData_Implementation(USereneSaveGame* SaveGame)`: Create FSavedDoorState, populate from bIsOpen/bIsLocked/CurrentAngle/OpenDirection, add to SaveGame->DoorStates.
- `ReadSaveData_Implementation(USereneSaveGame* SaveGame)`: Find matching FSavedDoorState by FName in SaveGame->DoorStates. Restore bIsOpen, bIsLocked, CurrentAngle, OpenDirection. Set TargetAngle = bIsOpen ? (OpenAngle * OpenDirection) : 0.0f. Apply DoorMesh rotation immediately (no interpolation on load -- snap to saved position).

Include SaveableInterface.h and SereneSaveGame.h.

**PickupActor.h** -- Add ISaveable inheritance. Override GetSaveId, WriteSaveData, ReadSaveData.

**PickupActor.cpp** -- Implement:
- `GetSaveId_Implementation`: return GetFName().
- `WriteSaveData_Implementation`: PickupActors don't write individual state -- their destruction is tracked by SaveSubsystem::DestroyedPickupTracker. This method can be a no-op or add GetFName() to the save's DestroyedPickupIds if not already there (but the subsystem handles this).
- `ReadSaveData_Implementation`: No-op -- destruction is handled by SaveSubsystem::ApplyPendingSaveData which destroys pickups by FName.
- **Critical addition to OnInteract_Implementation**: After the existing `Destroy()` call (when bDestroyOnPickup is true), first call `USaveSubsystem::TrackDestroyedPickup(GetFName())`. Get the subsystem via `GetGameInstance()->GetSubsystem<USaveSubsystem>()`. Check for null GameInstance and null subsystem.

**DrawerActor.h** -- Add ISaveable inheritance. Override GetSaveId, WriteSaveData, ReadSaveData. Promote bIsOpen and CurrentSlide from private to protected (ISaveable methods need access, and they're in the same class so actually private works -- but for consistency with DoorActor pattern, make them protected). Actually, the ISaveable implementations are member functions of DrawerActor itself, so they CAN access private members. Keep them private but implement the ISaveable methods in DrawerActor.cpp.

**DrawerActor.cpp** -- Implement:
- `GetSaveId_Implementation`: return GetFName().
- `WriteSaveData_Implementation`: Create FSavedDrawerState, populate from bIsOpen/CurrentSlide, add to SaveGame->DrawerStates.
- `ReadSaveData_Implementation`: Find matching FSavedDrawerState by FName. Restore bIsOpen and CurrentSlide. Snap DrawerMesh to saved position (compute relative location from DrawerInitialLocation + forward * CurrentSlide).

IMPORTANT: DrawerActor has DrawerInitialLocation cached in constructor. ReadSaveData must set DrawerMesh relative location to DrawerInitialLocation + ActorForwardVector * CurrentSlide. But the initial location is set in constructor via DrawerMesh->GetRelativeLocation(), which is correct since the actor is freshly spawned on level reload.
  </action>
  <verify>Project compiles. Verify DoorActor, PickupActor, DrawerActor all implement ISaveable (grep for "public ISaveable" in their headers). Verify PickupActor::OnInteract calls TrackDestroyedPickup before Destroy().</verify>
  <done>ISaveable interface expanded with USereneSaveGame* parameter. DoorActor saves/restores open/closed/locked/angle. PickupActor tracks destruction via SaveSubsystem. DrawerActor saves/restores open/closed/slide.</done>
</task>

<task type="auto">
  <name>Task 2: Death system + GameMode load flow + GrabAttack replacement</name>
  <files>
    Source/ProjectWalkingSim/Public/Core/SereneGameMode.h
    Source/ProjectWalkingSim/Private/Core/SereneGameMode.cpp
    Source/ProjectWalkingSim/Public/AI/Tasks/STT_GrabAttack.h
    Source/ProjectWalkingSim/Private/AI/Tasks/STT_GrabAttack.cpp
  </files>
  <action>
**SereneGameMode.h** -- Expand from minimal constructor-only class:

Add public methods:
- `void OnPlayerDeath()` -- Called when player dies (Wendigo grab completes). Shows Game Over widget, enables mouse cursor, sets input mode to UI Only. Creates UGameOverWidget (class reference via TSubclassOf UPROPERTY EditDefaultsOnly) and adds to viewport.
- `virtual void InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage) override` -- After Super::InitGame, check if SaveSubsystem has pending load data. If so, register a delegate with GetWorld()->OnActorsInitialized to call ApplyPendingSaveData at the right time.

Add protected members:
- `UPROPERTY(EditDefaultsOnly, Category = "UI") TSubclassOf<UUserWidget> GameOverWidgetClass` -- Blueprint subclass of GameOverWidget assigned here.
- `UPROPERTY() TObjectPtr<UUserWidget> GameOverWidgetInstance` -- Live instance.

Add private method:
- `void OnActorsReady(const FActorsInitializedParams& Params)` -- Called by OnActorsInitialized delegate. Gets SaveSubsystem, calls ApplyPendingSaveData(GetWorld()). This ensures all actors have been spawned and their constructors/BeginPlay have run.

IMPORTANT: For the player inventory and position restore, ApplyPendingSaveData (in SaveSubsystem) handles iterating ISaveable actors. But player position/inventory restore may need a slightly later timing. The approach:
1. In OnActorsReady, call SaveSubsystem->ApplyPendingSaveData(World).
2. Inside ApplyPendingSaveData, for player state: find the PlayerController, get its pawn, cast to ASereneCharacter. Set location via SetActorLocation + SetActorRotation. For inventory: get InventoryComponent, call a new method like `RestoreFromSaveData(const TArray<FInventorySlot>& SavedSlots)` -- or directly manipulate the Slots array. The simplest approach: the InventoryComponent already has a protected Slots array. Add a public `void SetSlots(const TArray<FInventorySlot>& InSlots)` method on InventoryComponent. However, that would touch InventoryComponent.h which is Plan 02's file scope... Actually, SaveSubsystem::ApplyPendingSaveData can iterate the SavedSlots and call TryAddItem for each. But that's slower and may fail if slots are full. The cleanest approach: SaveSubsystem directly sets the inventory by accessing InventoryComponent's Slots via a friend or new setter. Since this plan already modifies PickupActor (which uses InventoryComponent), let's add a simple `void RestoreSavedInventory(const TArray<FInventorySlot>& SavedSlots)` method to InventoryComponent.

Wait -- InventoryComponent.h is not in this plan's files_modified. Add it:

Actually, for minimal scope: SaveSubsystem::ApplyPendingSaveData can call InventoryComponent->GetSlots() to get a mutable ref... but GetSlots() returns const ref. We need a setter.

Resolution: In ApplyPendingSaveData, use a lightweight approach. Since SaveSubsystem already has access to the InventoryComponent via the character, and the Slots array is UPROPERTY(VisibleAnywhere), we can add a simple public RestoreSavedInventory method. Add this to InventoryComponent.h/cpp in this task since it's a one-line addition.

Add to files: InventoryComponent.h, InventoryComponent.cpp

**InventoryComponent.h** -- Add:
```cpp
/** Restore inventory from saved data. Replaces all current slots. Broadcasts OnInventoryChanged. */
UFUNCTION(BlueprintCallable, Category = "Inventory")
void RestoreSavedInventory(const TArray<FInventorySlot>& SavedSlots);
```

**InventoryComponent.cpp** -- Implement:
```cpp
void UInventoryComponent::RestoreSavedInventory(const TArray<FInventorySlot>& SavedSlots)
{
    Slots = SavedSlots;
    Slots.SetNum(MaxSlots); // Ensure exactly 8 slots
    OnInventoryChanged.Broadcast();
}
```

**SereneGameMode.cpp** -- Implement:
- Constructor: keep existing defaults.
- `InitGame`: Call Super::InitGame. Get SaveSubsystem via `GetGameInstance()->GetSubsystem<USaveSubsystem>()`. If `SaveSubsystem && SaveSubsystem->IsPendingLoad()`, bind to `GetWorld()->OnActorsInitialized.AddUObject(this, &ASereneGameMode::OnActorsReady)`.
- `OnActorsReady`: Get SaveSubsystem, call `ApplyPendingSaveData(GetWorld())`. Log success.
- `OnPlayerDeath`: Create GameOverWidget from class, add to viewport, set input mode.

Include SaveSubsystem.h, GameOverWidget.h (forward declare in header).

**STT_GrabAttack.cpp** -- Replace the `PlayerController->ConsoleCommand(TEXT("RestartLevel"))` in Tick() with:
```cpp
if (ASereneGameMode* GM = Cast<ASereneGameMode>(World->GetAuthGameMode()))
{
    GM->OnPlayerDeath();
}
```
Include SereneGameMode.h. Remove the RestartLevel console command entirely.

**STT_GrabAttack.h** -- No changes needed (the Tick signature doesn't change).
  </action>
  <verify>Project compiles. Verify STT_GrabAttack.cpp no longer contains "RestartLevel". Verify SereneGameMode.h declares OnPlayerDeath and InitGame override. Verify InventoryComponent.h declares RestoreSavedInventory.</verify>
  <done>Death triggers GameMode::OnPlayerDeath instead of RestartLevel. GameMode hooks into level init to apply pending save data. InventoryComponent has RestoreSavedInventory for load flow. Full death-to-reload pipeline is wired.</done>
</task>

</tasks>

<verification>
1. Project compiles without errors
2. `grep -r "RestartLevel" Source/` returns no results in STT_GrabAttack files
3. DoorActor, DrawerActor implement ISaveable (WriteSaveData/ReadSaveData with USereneSaveGame*)
4. PickupActor calls SaveSubsystem::TrackDestroyedPickup in OnInteract before Destroy
5. SereneGameMode::InitGame checks for pending load and binds OnActorsInitialized
6. SereneGameMode::OnPlayerDeath creates Game Over widget
</verification>

<success_criteria>
- ISaveable interface works with USereneSaveGame* parameter on all 3 actor types
- Death goes through OnPlayerDeath instead of RestartLevel
- Level reload triggers ApplyPendingSaveData which restores doors, drawers, destroys pickups, restores player position and inventory
- PickupActor destruction is tracked at runtime via SaveSubsystem
</success_criteria>

<output>
After completion, create `.planning/phases/07-save-system/07-02-SUMMARY.md`
</output>
