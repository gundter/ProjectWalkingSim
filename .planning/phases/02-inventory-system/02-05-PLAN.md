---
phase: 02-inventory-system
plan: 05
type: execute
wave: 3
depends_on: ["02-03", "02-04"]
files_modified:
  - Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h
  - Source/ProjectWalkingSim/Private/Inventory/InventoryComponent.cpp
  - Source/ProjectWalkingSim/Public/Player/HUD/InventoryWidget.h
  - Source/ProjectWalkingSim/Private/Player/HUD/InventoryWidget.cpp
  - Source/ProjectWalkingSim/Public/Player/HUD/SereneHUD.h
  - Source/ProjectWalkingSim/Private/Player/HUD/SereneHUD.cpp
autonomous: true

must_haves:
  truths:
    - "Player can select item A, click Combine, then click item B to attempt a combination"
    - "Failed combinations show feedback (delegate fires with reason text)"
    - "Player can select slots by pressing number keys 1-8"
    - "Player can cycle through slots with Q/E or arrow keys while inventory is open"
    - "Combine mode is visually indicated and can be cancelled by pressing Escape or clicking empty"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h"
      provides: "TryCombineItems method with recipe TMap"
      contains: "TryCombineItems"
    - path: "Source/ProjectWalkingSim/Public/Player/HUD/InventoryWidget.h"
      provides: "Combine mode state, keyboard navigation methods"
      contains: "EnterCombineMode"
  key_links:
    - from: "InventoryComponent.cpp"
      to: "CombineRecipes TMap"
      via: "TryCombineItems looks up pair in recipe map"
      pattern: "CombineRecipes"
    - from: "InventoryWidget.cpp"
      to: "InventoryComponent.h"
      via: "Combine flow calls TryCombineItems via delegate chain"
      pattern: "OnCombineRequested"
    - from: "SereneHUD.cpp"
      to: "InventoryComponent.h"
      via: "HandleCombineRequested calls TryCombineItems"
      pattern: "TryCombineItems"
---

<objective>
Add the combine system and keyboard navigation to the inventory.

Purpose: The combine system allows two-step item combination (select A -> Combine -> select B). The recipe backend is minimal (a TMap of pairs to results) since the demo has few or zero recipes, but the UI flow must work. Keyboard navigation lets players use number keys 1-8 for direct slot selection and Q/E or arrow keys for cycling. These are the remaining INVT-02 requirements.

Output: Modified 6 files across InventoryComponent, InventoryWidget, and SereneHUD.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-inventory-system/02-CONTEXT.md
@.planning/phases/02-inventory-system/02-RESEARCH.md
@.planning/phases/02-inventory-system/02-01-SUMMARY.md
@.planning/phases/02-inventory-system/02-02-SUMMARY.md
@.planning/phases/02-inventory-system/02-03-SUMMARY.md
@.planning/phases/02-inventory-system/02-04-SUMMARY.md

@Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h
@Source/ProjectWalkingSim/Public/Player/HUD/InventoryWidget.h
@Source/ProjectWalkingSim/Public/Player/HUD/SereneHUD.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Combine system backend + frontend</name>
  <files>
    Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h
    Source/ProjectWalkingSim/Private/Inventory/InventoryComponent.cpp
    Source/ProjectWalkingSim/Public/Player/HUD/InventoryWidget.h
    Source/ProjectWalkingSim/Private/Player/HUD/InventoryWidget.cpp
    Source/ProjectWalkingSim/Public/Player/HUD/SereneHUD.h
    Source/ProjectWalkingSim/Private/Player/HUD/SereneHUD.cpp
  </files>
  <action>
    **InventoryComponent.h additions:**
    - Add a struct or use TPair for recipes:
      ```cpp
      private:
          /** Combine recipes: {ItemA, ItemB} -> ResultItem. Order-independent (both permutations checked). */
          TMap<TPair<FName, FName>, FName> CombineRecipes;

          /** Initialize combine recipes. Called in BeginPlay after registry load. */
          void InitCombineRecipes();
      ```
    - Add public method:
      ```cpp
      /**
       * Attempt to combine items from two slots.
       * @param SlotIndexA First item slot
       * @param SlotIndexB Second item slot
       * @return true if combination succeeded, false if no recipe exists
       */
      UFUNCTION(BlueprintCallable, Category = "Inventory")
      bool TryCombineItems(int32 SlotIndexA, int32 SlotIndexB);
      ```
    - Add delegate for combine feedback:
      ```cpp
      DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCombineFailed, FText, Reason);

      UPROPERTY(BlueprintAssignable, Category = "Inventory")
      FOnCombineFailed OnCombineFailed;
      ```

    **InventoryComponent.cpp additions:**
    - InitCombineRecipes: For the demo, this is empty or has 1-2 placeholder recipes. Structure:
      ```cpp
      void UInventoryComponent::InitCombineRecipes()
      {
          // Add recipes here as the demo expands. Format: {ItemA, ItemB} -> Result
          // Example (commented out until actual items exist):
          // CombineRecipes.Add(TPair<FName,FName>(FName("Fuse"), FName("FuseBox")), FName("PoweredFuseBox"));
          UE_LOG(LogSerene, Log, TEXT("UInventoryComponent::InitCombineRecipes - %d recipes loaded."), CombineRecipes.Num());
      }
      ```
    - Call InitCombineRecipes at the end of BeginPlay
    - TryCombineItems:
      1. Validate both slot indices and ensure neither is empty
      2. Get ItemId from both slots
      3. Check recipe map with both orderings: (A,B) and (B,A)
      4. If recipe found:
         - Remove 1 quantity from both source slots
         - TryAddItem with result ItemId
         - Broadcast OnInventoryChanged
         - Log success
         - Return true
      5. If no recipe:
         - Broadcast OnCombineFailed with reason text "These items cannot be combined"
         - Log the attempt
         - Return false

    **InventoryWidget.h additions:**
    - Add combine mode state (private):
      ```cpp
      bool bInCombineMode = false;
      int32 CombineSourceSlotIndex = -1;
      ```
    - Add public methods:
      ```cpp
      /** Enter combine mode: first item selected, waiting for second. */
      void EnterCombineMode(int32 SourceSlotIndex);

      /** Exit combine mode without combining. */
      void ExitCombineMode();

      /** Returns true if in combine mode. */
      bool IsInCombineMode() const { return bInCombineMode; }
      ```
    - Add delegate:
      ```cpp
      DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnCombineSlotSelected, int32, SlotIndexA, int32, SlotIndexB);
      FOnCombineSlotSelected OnCombineRequested;
      ```

    **InventoryWidget.cpp additions:**
    - EnterCombineMode: Set bInCombineMode = true, store CombineSourceSlotIndex, visually highlight the source slot differently (e.g., call SetSelected with a "combine source" indicator -- or just keep it selected). Log enter combine mode.
    - ExitCombineMode: Reset bInCombineMode, CombineSourceSlotIndex = -1. Log exit.
    - Modify HandleSlotClicked: If bInCombineMode and a different slot is clicked, broadcast OnCombineRequested(CombineSourceSlotIndex, ClickedSlotIndex), then ExitCombineMode. If same slot clicked, exit combine mode (cancel). If empty slot clicked during combine mode, exit combine mode.

    **SereneHUD.h additions:**
    - Add private handler:
      ```cpp
      UFUNCTION()
      void HandleCombineRequested(int32 SlotIndexA, int32 SlotIndexB);
      ```

    **SereneHUD.cpp additions:**
    - In BeginPlay, bind the combine delegate:
      ```cpp
      InvWidget->OnCombineRequested.AddDynamic(this, &ASereneHUD::HandleCombineRequested);
      ```
    - Also bind when tooltip Combine button is clicked: The tooltip's OnCombineClicked should trigger the widget to enter combine mode. Add in BeginPlay or wherever tooltip delegates are bound:
      - Route the InventoryWidget's internal handling: When OnCombineClicked fires from tooltip, InventoryWidget enters combine mode. This means InventoryWidget needs to handle the tooltip's combine action internally. In NativeConstruct where tooltip delegates are bound, bind OnCombineClicked to a lambda or handler that calls EnterCombineMode(SelectedSlotIndex).
      - Actually, keep it simpler: In the HUD, HandleCombineButtonClicked (new handler) calls InventoryWidget->EnterCombineMode(SlotIndex). Add the handler and binding.

    - HandleCombineRequested:
      ```cpp
      if (!CachedInventoryComp) return;
      CachedInventoryComp->TryCombineItems(SlotIndexA, SlotIndexB);
      // Inventory change delegate will auto-refresh the UI
      ```

    Use LogSerene for all logging.
  </action>
  <verify>
    Run the UE build command:
    ```
    "C:\Program Files\Epic Games\UE_5.7\Engine\Binaries\DotNET\UnrealBuildTool\UnrealBuildTool.exe" ProjectWalkingSim Win64 Development -Project="C:\Unreal Projects\ProjectWalkingSim\ProjectWalkingSim.uproject" -WaitMutex -FromMsBuild
    ```
  </verify>
  <done>
    InventoryComponent has TryCombineItems with recipe TMap and OnCombineFailed delegate. InventoryWidget has combine mode (EnterCombineMode/ExitCombineMode) and broadcasts OnCombineRequested when second slot is selected. SereneHUD routes combine requests to InventoryComponent. Compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Keyboard navigation for inventory slots</name>
  <files>
    Source/ProjectWalkingSim/Public/Player/SerenePlayerController.h
    Source/ProjectWalkingSim/Private/Player/SerenePlayerController.cpp
    Source/ProjectWalkingSim/Public/Player/HUD/InventoryWidget.h
    Source/ProjectWalkingSim/Private/Player/HUD/InventoryWidget.cpp
  </files>
  <action>
    Add keyboard slot selection (number keys 1-8) and slot cycling (left/right arrow or Q/E) to the inventory. These only work when the inventory is open.

    **Approach:** Rather than creating 10 separate Input Actions for each number key and arrow, use a simpler approach: override `InputKey` on the PlayerController to handle keyboard shortcuts when inventory is open. This avoids IMC bloat and is standard for UI overlay input.

    Actually, the cleaner UE approach is to use existing IA actions. But for 1-8 number keys, that's 8 input actions which is excessive. The pragmatic approach: Handle key events in the InventoryWidget via `NativeOnKeyDown` override (UUserWidget supports this). When the widget has keyboard focus (which it does when inventory is open and FInputModeGameAndUI is active), key presses are routed to the widget.

    REVISED approach: Use `NativeOnKeyDown` on InventoryWidget for number keys and navigation. The widget gets focus when inventory opens.

    **InventoryWidget.h additions:**
    - Override: `virtual FReply NativeOnKeyDown(const FGeometry& InGeometry, const FKeyEvent& InKeyEvent) override;`
    - Add private method: `void NavigateSlot(int32 Direction);` -- cycles selected slot left (-1) or right (+1)
    - Add method to ShowInventory: After SetRenderOpacity, call `SetKeyboardFocus()` to receive key events

    **InventoryWidget.cpp additions:**
    - NativeOnKeyDown implementation:
      1. Get the key: `FKey Key = InKeyEvent.GetKey()`
      2. Number keys 1-8 for direct selection:
         ```cpp
         // Check number keys 1-8
         static const FKey NumberKeys[] = {
             EKeys::One, EKeys::Two, EKeys::Three, EKeys::Four,
             EKeys::Five, EKeys::Six, EKeys::Seven, EKeys::Eight
         };
         for (int32 i = 0; i < 8; i++)
         {
             if (Key == NumberKeys[i])
             {
                 SelectSlot(i);
                 return FReply::Handled();
             }
         }
         ```
      3. Arrow keys for cycling:
         ```cpp
         if (Key == EKeys::Left || Key == EKeys::A) // A also cycles when inventory open
         {
             // Don't consume A key -- it's used for movement
             // Only use Left arrow and dedicated nav keys
         }
         if (Key == EKeys::Left)
         {
             NavigateSlot(-1);
             return FReply::Handled();
         }
         if (Key == EKeys::Right)
         {
             NavigateSlot(1);
             return FReply::Handled();
         }
         ```
      4. Escape to close combine mode or deselect:
         ```cpp
         if (Key == EKeys::Escape)
         {
             if (bInCombineMode)
             {
                 ExitCombineMode();
             }
             else
             {
                 DeselectSlot();
             }
             return FReply::Handled();
         }
         ```
      5. Delete key for discard:
         ```cpp
         if (Key == EKeys::Delete && SelectedSlotIndex >= 0)
         {
             OnDiscardRequested.Broadcast(SelectedSlotIndex);
             return FReply::Handled();
         }
         ```
      6. Return `Super::NativeOnKeyDown(InGeometry, InKeyEvent)` for unhandled keys

    - NavigateSlot:
      ```cpp
      void UInventoryWidget::NavigateSlot(int32 Direction)
      {
          if (SlotWidgets.Num() == 0) return;

          int32 NewIndex;
          if (SelectedSlotIndex < 0)
          {
              // Nothing selected, select first (right) or last (left)
              NewIndex = (Direction > 0) ? 0 : SlotWidgets.Num() - 1;
          }
          else
          {
              NewIndex = SelectedSlotIndex + Direction;
              // Wrap around
              if (NewIndex < 0) NewIndex = SlotWidgets.Num() - 1;
              if (NewIndex >= SlotWidgets.Num()) NewIndex = 0;
          }
          SelectSlot(NewIndex);
      }
      ```

    - In ShowInventory: After SetRenderOpacity, call `SetKeyboardFocus()` so NativeOnKeyDown fires. Also set `SetIsFocusable(true)` in NativeConstruct.

    **SerenePlayerController.cpp modification:**
    - No changes needed if InventoryWidget handles keys via NativeOnKeyDown. BUT: We need to ensure number keys don't interfere with game input. Since we're in FInputModeGameAndUI, both game and UI input is active. The widget's NativeOnKeyDown consumes the event (FReply::Handled), preventing it from reaching game input.
    - One concern: WASD for movement must NOT be consumed by the widget. Only consume number keys, arrows, Escape, Delete. All other keys pass through via Super::NativeOnKeyDown.

    Use LogSerene for logging navigation events at Verbose level.
  </action>
  <verify>
    Run the UE build command:
    ```
    "C:\Program Files\Epic Games\UE_5.7\Engine\Binaries\DotNET\UnrealBuildTool\UnrealBuildTool.exe" ProjectWalkingSim Win64 Development -Project="C:\Unreal Projects\ProjectWalkingSim\ProjectWalkingSim.uproject" -WaitMutex -FromMsBuild
    ```
  </verify>
  <done>
    InventoryWidget handles NativeOnKeyDown for: number keys 1-8 (direct slot selection), left/right arrows (slot cycling with wraparound), Escape (exit combine mode or deselect), Delete (discard selected). WASD and other game input keys pass through unhandled. Widget gains keyboard focus when shown. Compiles cleanly.
  </done>
</task>

</tasks>

<verification>
- TryCombineItems exists on InventoryComponent with recipe TMap
- Combine mode flow: select item -> click Combine button -> click second item -> TryCombineItems called
- OnCombineFailed delegate fires with reason text on failed combination
- Number keys 1-8 select corresponding inventory slot when inventory is open
- Arrow keys cycle through slots with wraparound
- Escape exits combine mode or deselects current slot
- Delete key triggers discard on selected slot
- WASD movement still works while inventory is open (keys not consumed)
- Full UE build succeeds
</verification>

<success_criteria>
The combine system UI flow works end-to-end (even with zero recipes). Keyboard navigation provides full non-mouse control of inventory slots. All key events are properly consumed or passed through without interfering with movement.
</success_criteria>

<output>
After completion, create `.planning/phases/02-inventory-system/02-05-SUMMARY.md`
</output>
