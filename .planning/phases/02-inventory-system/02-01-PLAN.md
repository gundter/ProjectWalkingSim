---
phase: 02-inventory-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Source/ProjectWalkingSim/Public/Inventory/InventoryTypes.h
  - Source/ProjectWalkingSim/Private/Inventory/InventoryTypes.cpp
  - Source/ProjectWalkingSim/Public/Inventory/ItemDataAsset.h
  - Source/ProjectWalkingSim/Private/Inventory/ItemDataAsset.cpp
  - Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h
  - Source/ProjectWalkingSim/Private/Inventory/InventoryComponent.cpp
  - Source/ProjectWalkingSim/Public/Tags/SereneTags.h
  - Source/ProjectWalkingSim/Private/Tags/SereneTags.cpp
autonomous: true

must_haves:
  truths:
    - "InventoryComponent can add items to slots and report when full"
    - "InventoryComponent can remove items by slot index"
    - "InventoryComponent can look up item data by FName ItemId"
    - "Stackable items consolidate into existing slots before using new ones"
    - "OnInventoryChanged delegate fires on every add/remove operation"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/Inventory/InventoryTypes.h"
      provides: "FInventorySlot struct, EItemType enum, delegate declarations"
      contains: "FInventorySlot"
    - path: "Source/ProjectWalkingSim/Public/Inventory/ItemDataAsset.h"
      provides: "UItemDataAsset with ItemId, DisplayName, Description, Icon, WorldMesh, ItemType, bIsStackable, bIsKeyItem, ItemTag"
      contains: "UItemDataAsset"
    - path: "Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h"
      provides: "UInventoryComponent with TryAddItem, RemoveItem, HasItem, IsFull, GetSlots, GetItemData, DiscardItem, OnInventoryChanged"
      contains: "UInventoryComponent"
    - path: "Source/ProjectWalkingSim/Public/Tags/SereneTags.h"
      provides: "Item-related gameplay tags"
      contains: "TAG_Item"
  key_links:
    - from: "InventoryComponent.h"
      to: "ItemDataAsset.h"
      via: "GetItemData looks up UItemDataAsset by FName"
      pattern: "GetItemData.*FName"
    - from: "InventoryComponent.h"
      to: "InventoryTypes.h"
      via: "Slots array uses FInventorySlot"
      pattern: "TArray<FInventorySlot>"
    - from: "ItemDataAsset.cpp"
      to: "GetPrimaryAssetId"
      via: "Override returns FPrimaryAssetId for Asset Manager"
      pattern: "GetPrimaryAssetId"
---

<objective>
Create the inventory data foundation: item type enum, slot struct, item data asset, and inventory component.

Purpose: This is the core data layer that everything else in Phase 2 depends on. The InventoryComponent manages 8 slots of FInventorySlot, looks up item definitions from UItemDataAsset instances, and broadcasts OnInventoryChanged for UI. The ItemDataAsset defines static item properties (name, description, icon, mesh, type, stackability). All inventory logic lives here -- widgets and actors only call into this component.

Scope note (INVT-04): This phase implements key item functionality (keys for locked doors, codes for padlocks) and the structural Use/Combine/Discard buttons. Healing items and health system are deferred to post-demo (demo uses instant death on Wendigo catch). Flashlight is a separate equipped tool implemented in Phase 6, not an inventory item. The "Use" action handler (HandleUseRequested in SereneHUD) is a logging placeholder for this phase since key items are consumed contextually at locked doors rather than from the inventory UI. Use button remains visible but its action logs only -- items that have no direct "use" action will get proper feedback in a future iteration.

Output: 6 new files (3 header + 3 source) in Inventory/ directory, plus expanded SereneTags.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-inventory-system/02-CONTEXT.md
@.planning/phases/02-inventory-system/02-RESEARCH.md

@Source/ProjectWalkingSim/Public/Tags/SereneTags.h
@Source/ProjectWalkingSim/Private/Tags/SereneTags.cpp
@Source/ProjectWalkingSim/Public/Player/Components/StaminaComponent.h
@Source/ProjectWalkingSim/Public/Core/SereneLogChannels.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: InventoryTypes and ItemDataAsset</name>
  <files>
    Source/ProjectWalkingSim/Public/Inventory/InventoryTypes.h
    Source/ProjectWalkingSim/Private/Inventory/InventoryTypes.cpp
    Source/ProjectWalkingSim/Public/Inventory/ItemDataAsset.h
    Source/ProjectWalkingSim/Private/Inventory/ItemDataAsset.cpp
    Source/ProjectWalkingSim/Public/Tags/SereneTags.h
    Source/ProjectWalkingSim/Private/Tags/SereneTags.cpp
  </files>
  <action>
    Create the Inventory/ directories under both Public/ and Private/.

    **InventoryTypes.h / .cpp:**
    - `EItemType` enum (BlueprintType): KeyItem, Consumable, Tool, Puzzle
    - `FInventorySlot` struct (BlueprintType, GENERATED_BODY):
      - `FName ItemId = NAME_None` (BlueprintReadOnly)
      - `int32 Quantity = 0` (BlueprintReadOnly)
      - `bool IsEmpty() const` (inline: ItemId == NAME_None || Quantity <= 0)
    - Delegate declarations:
      - `DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInventoryChanged)` -- no params, fires on any slot change
      - `DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnInventoryActionFailed, FName, ItemId, FText, Reason)` -- for "inventory full" feedback
    - .cpp file just includes the header (needed for GENERATED_BODY)

    **ItemDataAsset.h / .cpp:**
    - Subclass of `UPrimaryDataAsset` (UCLASS BlueprintType)
    - Properties (all EditDefaultsOnly, BlueprintReadOnly, Category = "Item"):
      - `FName ItemId` -- unique identifier matching APickupActor::ItemId
      - `FText DisplayName`
      - `FText Description`
      - `EItemType ItemType = EItemType::KeyItem`
      - `bool bIsStackable = false`
      - `int32 MaxStackSize = 1` (EditCondition = "bIsStackable", ClampMin 1, ClampMax 99)
      - `bool bIsKeyItem = false`
      - `FGameplayTag ItemTag` -- for item-specific logic (e.g., Item.Key.FrontDoor)
    - Properties (Category = "Item|Visuals"):
      - `TSoftObjectPtr<UTexture2D> Icon`
      - `TSoftObjectPtr<UStaticMesh> WorldMesh`
    - Override `GetPrimaryAssetId()` returning `FPrimaryAssetId("Item", GetFName())`
    - .cpp implements GetPrimaryAssetId only

    **SereneTags.h / .cpp expansion:**
    - Add under existing namespace SereneTags:
      - `TAG_Item_Key` ("Item.Key")
      - `TAG_Item_Consumable` ("Item.Consumable")
      - `TAG_Item_Tool` ("Item.Tool")
      - `TAG_Item_Puzzle` ("Item.Puzzle")
      - `TAG_Player_InventoryOpen` ("Player.InventoryOpen")
    - Add matching UE_DEFINE_GAMEPLAY_TAG entries in SereneTags.cpp

    Follow existing code patterns:
    - Copyright header: `// Copyright Null Lantern.`
    - Use LogSerene for all logging
    - Use PROJECTWALKINGSIM_API on all exported classes/structs
    - Include guards via #pragma once
  </action>
  <verify>
    Run the UE build command. All new files must compile without errors or warnings:
    ```
    "C:\Program Files\Epic Games\UE_5.7\Engine\Binaries\DotNET\UnrealBuildTool\UnrealBuildTool.exe" ProjectWalkingSim Win64 Development -Project="C:\Unreal Projects\ProjectWalkingSim\ProjectWalkingSim.uproject" -WaitMutex -FromMsBuild
    ```
  </verify>
  <done>
    InventoryTypes.h defines EItemType enum and FInventorySlot struct. ItemDataAsset.h defines UItemDataAsset with all item properties and GetPrimaryAssetId override. SereneTags.h has 5 new inventory/item tags. All compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: InventoryComponent</name>
  <files>
    Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h
    Source/ProjectWalkingSim/Private/Inventory/InventoryComponent.cpp
  </files>
  <action>
    Create UInventoryComponent as a UActorComponent (BlueprintSpawnableComponent, ClassGroup=(Custom)).

    **Header (InventoryComponent.h):**
    - Include InventoryTypes.h, forward-declare UItemDataAsset
    - `static constexpr int32 MaxSlots = 8;`
    - Protected: `TArray<FInventorySlot> Slots` (VisibleAnywhere, BlueprintReadOnly) -- initialized to MaxSlots empty slots in constructor
    - Protected: `TMap<FName, TObjectPtr<UItemDataAsset>> ItemRegistry` -- populated at BeginPlay via Asset Manager scan
    - Public delegates:
      - `FOnInventoryChanged OnInventoryChanged` (BlueprintAssignable)
      - `FOnInventoryActionFailed OnInventoryActionFailed` (BlueprintAssignable)
    - Public functions (all BlueprintCallable, Category = "Inventory"):
      - `bool TryAddItem(FName ItemId, int32 Quantity = 1)` -- returns false if no room; stacks if item already exists and stackable; broadcasts OnInventoryChanged on success, OnInventoryActionFailed on failure
      - `bool RemoveItem(int32 SlotIndex, int32 Quantity = 1)` -- removes quantity from slot, clears slot if quantity reaches 0; broadcasts OnInventoryChanged
      - `bool RemoveItemByName(FName ItemId, int32 Quantity = 1)` -- finds first slot with ItemId, removes quantity
      - `bool HasItem(FName ItemId) const`
      - `int32 GetItemCount(FName ItemId) const` -- total quantity across all slots
      - `bool IsFull() const` -- all MaxSlots occupied (non-empty)
      - `const TArray<FInventorySlot>& GetSlots() const`
      - `const UItemDataAsset* GetItemData(FName ItemId) const` -- lookup from ItemRegistry
      - `void DiscardItem(int32 SlotIndex)` -- spawns APickupActor in front of player with impulse, then removes from inventory. Calculate spawn point: get player viewpoint, spawn 80cm forward, apply impulse (150 forward + 50 up). Use ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn. Forward-declare APickupActor in header, include in .cpp.
      - `int32 FindFirstEmptySlot() const` -- returns index or -1
      - `int32 FindSlotWithItem(FName ItemId) const` -- returns index or -1

    **Implementation (InventoryComponent.cpp):**
    - Constructor: Initialize Slots to MaxSlots empty FInventorySlots via `Slots.SetNum(MaxSlots)`
    - BeginPlay: Load all UItemDataAsset via UAssetManager:
      ```
      UAssetManager& AM = UAssetManager::Get();
      TArray<FPrimaryAssetId> AssetList;
      AM.GetPrimaryAssetIdList(FPrimaryAssetType("Item"), AssetList);
      ```
      For each asset, call `AM.GetPrimaryAssetObject(AssetId)` and if loaded, cast to UItemDataAsset and add to ItemRegistry. If not loaded, use `AM.LoadPrimaryAsset` synchronously (small dataset, acceptable). Log count of registered items.
    - TryAddItem: First check if item exists in registry (warn if not). If stackable and already in a slot, add to existing stack (respect MaxStackSize). Otherwise find empty slot. Broadcast OnInventoryChanged on success.
    - RemoveItem: Validate slot index, reduce quantity, clear slot if empty. Broadcast OnInventoryChanged.
    - DiscardItem: Get owner pawn's viewpoint via controller. Spawn APickupActor at eye + 80cm forward. Call `InitFromItemData` on the spawned actor (add this method to PickupActor in Plan 03 -- for now just set ItemId and Quantity directly on the spawned actor's public members). Enable physics and apply impulse. Then call RemoveItem.

    Use LogSerene for all logging. Log TryAddItem success/failure, RemoveItem, DiscardItem at Log level. Log registry loading at Log level. Log item-not-found-in-registry at Warning level.
  </action>
  <verify>
    Run the UE build command. InventoryComponent must compile without errors or warnings:
    ```
    "C:\Program Files\Epic Games\UE_5.7\Engine\Binaries\DotNET\UnrealBuildTool\UnrealBuildTool.exe" ProjectWalkingSim Win64 Development -Project="C:\Unreal Projects\ProjectWalkingSim\ProjectWalkingSim.uproject" -WaitMutex -FromMsBuild
    ```
    Verify that `InventoryComponent.h` includes `TryAddItem`, `RemoveItem`, `HasItem`, `IsFull`, `GetSlots`, `GetItemData`, `DiscardItem`, and both delegate declarations.
  </verify>
  <done>
    UInventoryComponent compiles with all public API methods. 8-slot TArray initialized in constructor. Item registry loads from Asset Manager in BeginPlay. OnInventoryChanged and OnInventoryActionFailed delegates declared and broadcast correctly. DiscardItem spawns APickupActor with physics impulse.
  </done>
</task>

</tasks>

<verification>
- All 8 files exist and compile: InventoryTypes.h/.cpp, ItemDataAsset.h/.cpp, InventoryComponent.h/.cpp, updated SereneTags.h/.cpp
- No new Build.cs dependencies added (all modules already present)
- FInventorySlot struct has ItemId (FName) and Quantity (int32)
- UItemDataAsset has GetPrimaryAssetId returning FPrimaryAssetId("Item", GetFName())
- UInventoryComponent has 8-slot array, TryAddItem, RemoveItem, DiscardItem, delegates
- SereneTags namespace includes TAG_Item_Key, TAG_Item_Consumable, TAG_Item_Tool, TAG_Item_Puzzle, TAG_Player_InventoryOpen
</verification>

<success_criteria>
Full UE build succeeds with zero errors. The inventory data layer is complete: types, data asset, and component with all public API methods documented in the RESEARCH.md pattern.
</success_criteria>

<output>
After completion, create `.planning/phases/02-inventory-system/02-01-SUMMARY.md`
</output>
