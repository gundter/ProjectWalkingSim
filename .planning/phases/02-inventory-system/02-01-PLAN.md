---
phase: 02-inventory-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Source/ProjectWalkingSim/Public/Inventory/InventoryTypes.h
  - Source/ProjectWalkingSim/Private/Inventory/InventoryTypes.cpp
  - Source/ProjectWalkingSim/Public/Inventory/ItemDataAsset.h
  - Source/ProjectWalkingSim/Private/Inventory/ItemDataAsset.cpp
  - Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h
  - Source/ProjectWalkingSim/Private/Inventory/InventoryComponent.cpp
  - Source/ProjectWalkingSim/Public/Tags/SereneTags.h
  - Source/ProjectWalkingSim/Private/Tags/SereneTags.cpp
  - Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
  - Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
autonomous: true

must_haves:
  truths:
    - "InventoryComponent can add items to slots and report when full"
    - "InventoryComponent can remove items by slot index"
    - "InventoryComponent can look up item data by FName ItemId"
    - "Stackable items consolidate into existing slots before using new ones"
    - "OnInventoryChanged delegate fires on every add/remove operation"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/Inventory/InventoryTypes.h"
      provides: "FInventorySlot struct, EItemType enum, delegate declarations"
      contains: "FInventorySlot"
    - path: "Source/ProjectWalkingSim/Public/Inventory/ItemDataAsset.h"
      provides: "UItemDataAsset with ItemId, DisplayName, Description, Icon, WorldMesh, ItemType, bIsStackable, bIsKeyItem, ItemTag"
      contains: "UItemDataAsset"
    - path: "Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h"
      provides: "UInventoryComponent with TryAddItem, RemoveItem, HasItem, IsFull, GetSlots, GetItemData, DiscardItem, OnInventoryChanged"
      contains: "UInventoryComponent"
    - path: "Source/ProjectWalkingSim/Public/Tags/SereneTags.h"
      provides: "Item-related gameplay tags"
      contains: "TAG_Item"
    - path: "Source/ProjectWalkingSim/Public/Interaction/PickupActor.h"
      provides: "Minimal InitFromItemData public method for DiscardItem to call"
      contains: "InitFromItemData"
  key_links:
    - from: "InventoryComponent.h"
      to: "ItemDataAsset.h"
      via: "GetItemData looks up UItemDataAsset by FName"
      pattern: "GetItemData.*FName"
    - from: "InventoryComponent.h"
      to: "InventoryTypes.h"
      via: "Slots array uses FInventorySlot"
      pattern: "TArray<FInventorySlot>"
    - from: "ItemDataAsset.cpp"
      to: "GetPrimaryAssetId"
      via: "Override returns FPrimaryAssetId for Asset Manager"
      pattern: "GetPrimaryAssetId"
    - from: "InventoryComponent.cpp"
      to: "PickupActor.h"
      via: "DiscardItem spawns APickupActor and calls InitFromItemData"
      pattern: "InitFromItemData"
---

<objective>
Create the inventory data foundation: item type enum, slot struct, item data asset, and inventory component. Also add a minimal InitFromItemData method to PickupActor so that DiscardItem can compile.

Purpose: This is the core data layer that everything else in Phase 2 depends on. The InventoryComponent manages 8 slots of FInventorySlot, looks up item definitions from UItemDataAsset instances, and broadcasts OnInventoryChanged for UI. The ItemDataAsset defines static item properties (name, description, icon, mesh, type, stackability). All inventory logic lives here -- widgets and actors only call into this component.

Scope note (INVT-04): This phase implements key item functionality (keys for locked doors, codes for padlocks) and the structural Use/Combine/Discard buttons. The following are explicitly deferred to future iterations:
- Healing items and health system (demo uses instant death on Wendigo catch)
- Flashlight as inventory item (separate equipped tool in Phase 6)
- Key item discard confirmation dialog (key items CAN be discarded with a log warning, but the user-facing confirmation dialog is deferred to a polish pass)
- "Use" action handler beyond logging placeholder (key items are consumed contextually at locked doors, not from inventory UI)

Output: 6 new files (3 header + 3 source) in Inventory/ directory, plus expanded SereneTags, plus modified PickupActor (minimal InitFromItemData).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-inventory-system/02-CONTEXT.md
@.planning/phases/02-inventory-system/02-RESEARCH.md

@Source/ProjectWalkingSim/Public/Tags/SereneTags.h
@Source/ProjectWalkingSim/Private/Tags/SereneTags.cpp
@Source/ProjectWalkingSim/Public/Player/Components/StaminaComponent.h
@Source/ProjectWalkingSim/Public/Core/SereneLogChannels.h
@Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
@Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: InventoryTypes and ItemDataAsset</name>
  <files>
    Source/ProjectWalkingSim/Public/Inventory/InventoryTypes.h
    Source/ProjectWalkingSim/Private/Inventory/InventoryTypes.cpp
    Source/ProjectWalkingSim/Public/Inventory/ItemDataAsset.h
    Source/ProjectWalkingSim/Private/Inventory/ItemDataAsset.cpp
    Source/ProjectWalkingSim/Public/Tags/SereneTags.h
    Source/ProjectWalkingSim/Private/Tags/SereneTags.cpp
  </files>
  <action>
    Create the Inventory/ directories under both Public/ and Private/.

    **InventoryTypes.h / .cpp:**
    - `EItemType` enum (BlueprintType): KeyItem, Consumable, Tool, Puzzle
    - `FInventorySlot` struct (BlueprintType, GENERATED_BODY):
      - `FName ItemId = NAME_None` (BlueprintReadOnly)
      - `int32 Quantity = 0` (BlueprintReadOnly)
      - `bool IsEmpty() const` (inline: ItemId == NAME_None || Quantity <= 0)
    - Delegate declarations:
      - `DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInventoryChanged)` -- no params, fires on any slot change
      - `DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnInventoryActionFailed, FName, ItemId, FText, Reason)` -- for "inventory full" feedback
    - .cpp file just includes the header (needed for GENERATED_BODY)

    **ItemDataAsset.h / .cpp:**
    - Subclass of `UPrimaryDataAsset` (UCLASS BlueprintType)
    - Properties (all EditDefaultsOnly, BlueprintReadOnly, Category = "Item"):
      - `FName ItemId` -- unique identifier matching APickupActor::ItemId
      - `FText DisplayName`
      - `FText Description`
      - `EItemType ItemType = EItemType::KeyItem`
      - `bool bIsStackable = false`
      - `int32 MaxStackSize = 1` (EditCondition = "bIsStackable", ClampMin 1, ClampMax 99)
      - `bool bIsKeyItem = false`
      - `FGameplayTag ItemTag` -- for item-specific logic (e.g., Item.Key.FrontDoor)
    - Properties (Category = "Item|Visuals"):
      - `TSoftObjectPtr<UTexture2D> Icon`
      - `TSoftObjectPtr<UStaticMesh> WorldMesh`
    - Override `GetPrimaryAssetId()` returning `FPrimaryAssetId("Item", GetFName())`
    - .cpp implements GetPrimaryAssetId only

    **SereneTags.h / .cpp expansion:**
    - Add under existing namespace SereneTags:
      - `TAG_Item_Key` ("Item.Key")
      - `TAG_Item_Consumable` ("Item.Consumable")
      - `TAG_Item_Tool` ("Item.Tool")
      - `TAG_Item_Puzzle` ("Item.Puzzle")
      - `TAG_Player_InventoryOpen` ("Player.InventoryOpen")
    - Add matching UE_DEFINE_GAMEPLAY_TAG entries in SereneTags.cpp

    Follow existing code patterns:
    - Copyright header: `// Copyright Null Lantern.`
    - Use LogSerene for all logging
    - Use PROJECTWALKINGSIM_API on all exported classes/structs
    - Include guards via #pragma once
  </action>
  <verify>
    Run the UE build command. All new files must compile without errors or warnings:
    ```
    "C:\Program Files\Epic Games\UE_5.7\Engine\Binaries\DotNET\UnrealBuildTool\UnrealBuildTool.exe" ProjectWalkingSim Win64 Development -Project="C:\Unreal Projects\ProjectWalkingSim\ProjectWalkingSim.uproject" -WaitMutex -FromMsBuild
    ```
  </verify>
  <done>
    InventoryTypes.h defines EItemType enum and FInventorySlot struct. ItemDataAsset.h defines UItemDataAsset with all item properties and GetPrimaryAssetId override. SereneTags.h has 5 new inventory/item tags. All compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: InventoryComponent and minimal PickupActor::InitFromItemData</name>
  <files>
    Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h
    Source/ProjectWalkingSim/Private/Inventory/InventoryComponent.cpp
    Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
    Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
  </files>
  <action>
    Create UInventoryComponent as a UActorComponent (BlueprintSpawnableComponent, ClassGroup=(Custom)).
    Also add a minimal InitFromItemData method to APickupActor so DiscardItem compiles in this wave.

    **PickupActor.h changes:**
    - Add forward declaration above the UCLASS: `class UItemDataAsset;`
    - Add a public method declaration:
      ```cpp
      public:
          /**
           * Initialize this pickup from item data. Used when spawning discarded items.
           * Minimal version: sets ItemId and Quantity. Plan 03 extends this with mesh loading.
           */
          void InitFromItemData(FName InItemId, int32 InQuantity, const UItemDataAsset* ItemData);
      ```
    - Keep ItemId and Quantity as protected -- InitFromItemData is the public setter.

    **PickupActor.cpp changes:**
    - Add include: `#include "Inventory/ItemDataAsset.h"`
    - Implement InitFromItemData (minimal version):
      ```cpp
      void APickupActor::InitFromItemData(FName InItemId, int32 InQuantity, const UItemDataAsset* ItemData)
      {
          ItemId = InItemId;
          Quantity = InQuantity;

          // Mesh loading and interaction text update added in Plan 03
          UE_LOG(LogSerene, Log, TEXT("APickupActor::InitFromItemData - Initialized with ItemId=%s, Quantity=%d"),
              *InItemId.ToString(), InQuantity);
      }
      ```
    - This is intentionally minimal. Plan 03 will expand InitFromItemData to also load WorldMesh from ItemData and update InteractionText.

    **Header (InventoryComponent.h):**
    - Include InventoryTypes.h, forward-declare UItemDataAsset
    - `static constexpr int32 MaxSlots = 8;`
    - Protected: `TArray<FInventorySlot> Slots` (VisibleAnywhere, BlueprintReadOnly) -- initialized to MaxSlots empty slots in constructor
    - Protected: `TMap<FName, TObjectPtr<UItemDataAsset>> ItemRegistry` -- populated at BeginPlay via Asset Manager scan
    - Public delegates:
      - `FOnInventoryChanged OnInventoryChanged` (BlueprintAssignable)
      - `FOnInventoryActionFailed OnInventoryActionFailed` (BlueprintAssignable)
    - Public functions (all BlueprintCallable, Category = "Inventory"):
      - `bool TryAddItem(FName ItemId, int32 Quantity = 1)` -- returns false if no room; stacks if item already exists and stackable; broadcasts OnInventoryChanged on success, OnInventoryActionFailed on failure
      - `bool RemoveItem(int32 SlotIndex, int32 Quantity = 1)` -- removes quantity from slot, clears slot if quantity reaches 0; broadcasts OnInventoryChanged
      - `bool RemoveItemByName(FName ItemId, int32 Quantity = 1)` -- finds first slot with ItemId, removes quantity
      - `bool HasItem(FName ItemId) const`
      - `int32 GetItemCount(FName ItemId) const` -- total quantity across all slots
      - `bool IsFull() const` -- all MaxSlots occupied (non-empty)
      - `const TArray<FInventorySlot>& GetSlots() const`
      - `const UItemDataAsset* GetItemData(FName ItemId) const` -- lookup from ItemRegistry
      - `void DiscardItem(int32 SlotIndex)` -- spawns APickupActor in front of player with impulse, then removes from inventory. Calculate spawn point: get player viewpoint, spawn 80cm forward, apply impulse (150 forward + 50 up). Use ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn. Forward-declare APickupActor in header, include in .cpp.
      - `int32 FindFirstEmptySlot() const` -- returns index or -1
      - `int32 FindSlotWithItem(FName ItemId) const` -- returns index or -1

    **Implementation (InventoryComponent.cpp):**
    - Constructor: Initialize Slots to MaxSlots empty FInventorySlots via `Slots.SetNum(MaxSlots)`
    - BeginPlay: Load all UItemDataAsset via UAssetManager:
      ```
      UAssetManager& AM = UAssetManager::Get();
      TArray<FPrimaryAssetId> AssetList;
      AM.GetPrimaryAssetIdList(FPrimaryAssetType("Item"), AssetList);
      ```
      For each asset, call `AM.GetPrimaryAssetObject(AssetId)` and if loaded, cast to UItemDataAsset and add to ItemRegistry. If not loaded, use `AM.LoadPrimaryAsset` synchronously (small dataset, acceptable). Log count of registered items.
    - TryAddItem: First check if item exists in registry (warn if not). If stackable and already in a slot, add to existing stack (respect MaxStackSize). Otherwise find empty slot. Broadcast OnInventoryChanged on success.
    - RemoveItem: Validate slot index, reduce quantity, clear slot if empty. Broadcast OnInventoryChanged.
    - DiscardItem: Get owner pawn's viewpoint via controller. Spawn APickupActor at eye + 80cm forward. Call `InitFromItemData` on the spawned actor, passing the slot's ItemId, Quantity, and GetItemData result. Enable physics and apply impulse. Then call RemoveItem. This compiles because InitFromItemData was added to PickupActor earlier in this same task.

    Use LogSerene for all logging. Log TryAddItem success/failure, RemoveItem, DiscardItem at Log level. Log registry loading at Log level. Log item-not-found-in-registry at Warning level.
  </action>
  <verify>
    Run the UE build command. InventoryComponent and PickupActor must compile without errors or warnings:
    ```
    "C:\Program Files\Epic Games\UE_5.7\Engine\Binaries\DotNET\UnrealBuildTool\UnrealBuildTool.exe" ProjectWalkingSim Win64 Development -Project="C:\Unreal Projects\ProjectWalkingSim\ProjectWalkingSim.uproject" -WaitMutex -FromMsBuild
    ```
    Verify that `InventoryComponent.h` includes `TryAddItem`, `RemoveItem`, `HasItem`, `IsFull`, `GetSlots`, `GetItemData`, `DiscardItem`, and both delegate declarations.
    Verify that `PickupActor.h` includes `InitFromItemData` public method declaration.
  </verify>
  <done>
    UInventoryComponent compiles with all public API methods. 8-slot TArray initialized in constructor. Item registry loads from Asset Manager in BeginPlay. OnInventoryChanged and OnInventoryActionFailed delegates declared and broadcast correctly. DiscardItem spawns APickupActor and calls InitFromItemData which compiles because the minimal version was added to PickupActor in this same task. PickupActor::InitFromItemData sets ItemId and Quantity (mesh loading deferred to Plan 03).
  </done>
</task>

</tasks>

<verification>
- All 8 new files exist and compile: InventoryTypes.h/.cpp, ItemDataAsset.h/.cpp, InventoryComponent.h/.cpp, updated SereneTags.h/.cpp
- PickupActor.h/.cpp modified: InitFromItemData public method added (minimal version)
- No new Build.cs dependencies added (all modules already present)
- FInventorySlot struct has ItemId (FName) and Quantity (int32)
- UItemDataAsset has GetPrimaryAssetId returning FPrimaryAssetId("Item", GetFName())
- UInventoryComponent has 8-slot array, TryAddItem, RemoveItem, DiscardItem, delegates
- DiscardItem calls InitFromItemData on spawned APickupActor -- compiles because method exists in this wave
- SereneTags namespace includes TAG_Item_Key, TAG_Item_Consumable, TAG_Item_Tool, TAG_Item_Puzzle, TAG_Player_InventoryOpen
</verification>

<success_criteria>
Full UE build succeeds with zero errors. The inventory data layer is complete: types, data asset, and component with all public API methods documented in the RESEARCH.md pattern. PickupActor has a minimal InitFromItemData that DiscardItem can call without compilation errors.
</success_criteria>

<output>
After completion, create `.planning/phases/02-inventory-system/02-01-SUMMARY.md`
</output>
