---
phase: 02-inventory-system
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
  - Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
  - Source/ProjectWalkingSim/Public/Interaction/DoorActor.h
  - Source/ProjectWalkingSim/Private/Interaction/DoorActor.cpp
autonomous: true

must_haves:
  truths:
    - "PickupActor adds item to player inventory on interact instead of just logging"
    - "PickupActor shows 'Inventory Full' when player inventory has no room"
    - "PickupActor can be initialized from item data for spawning discarded items"
    - "DoorActor can be locked with a RequiredItemId and consumes the key on unlock"
    - "Locked door shows 'Locked' as interaction text until unlocked"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/Interaction/PickupActor.h"
      provides: "PickupActor with inventory integration, CanInteract check, full InitFromItemData"
      contains: "InitFromItemData"
    - path: "Source/ProjectWalkingSim/Public/Interaction/DoorActor.h"
      provides: "DoorActor with RequiredItemId, bIsLocked, key consumption on unlock"
      contains: "RequiredItemId"
  key_links:
    - from: "PickupActor.cpp"
      to: "InventoryComponent.h"
      via: "OnInteract calls TryAddItem on interactor's InventoryComponent"
      pattern: "TryAddItem"
    - from: "PickupActor.cpp"
      to: "InventoryComponent.h"
      via: "CanInteract checks IsFull on interactor's InventoryComponent"
      pattern: "IsFull"
    - from: "DoorActor.cpp"
      to: "InventoryComponent.h"
      via: "OnInteract calls HasItem then RemoveItemByName to consume key"
      pattern: "RemoveItemByName"
---

<objective>
Integrate the inventory system with existing interactable actors: PickupActor gains real inventory integration and DoorActor gains locked-door support.

Purpose: PickupActor was a Phase 1 placeholder that just logs and destroys. Now it calls InventoryComponent::TryAddItem, checks IsFull for the interaction prompt, and supports full InitFromItemData for spawning discarded items (extending the minimal version added in Plan 01). DoorActor gets optional locked state requiring a specific key item that is consumed on unlock.

Output: Modified 4 files (2 headers + 2 sources) for PickupActor and DoorActor.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-inventory-system/02-CONTEXT.md
@.planning/phases/02-inventory-system/02-RESEARCH.md
@.planning/phases/02-inventory-system/02-01-SUMMARY.md

@Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
@Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
@Source/ProjectWalkingSim/Public/Interaction/DoorActor.h
@Source/ProjectWalkingSim/Private/Interaction/DoorActor.cpp
@Source/ProjectWalkingSim/Public/Interaction/InteractableBase.h
@Source/ProjectWalkingSim/Public/Inventory/InventoryComponent.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: PickupActor inventory integration</name>
  <files>
    Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
    Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
  </files>
  <action>
    Modify APickupActor to integrate with the inventory system. NOTE: Plan 01 already added a minimal `InitFromItemData` method (sets ItemId and Quantity only) and the `UItemDataAsset` forward declaration/include. This task extends that method and adds the remaining inventory integration.

    **Header changes (PickupActor.h):**
    - InitFromItemData declaration already exists from Plan 01 -- no change needed to declaration
    - Add `CanInteract_Implementation` override declaration:
      `virtual bool CanInteract_Implementation(AActor* Interactor) const override;`
    - Add `GetInteractionText_Implementation` override declaration:
      `virtual FText GetInteractionText_Implementation() const override;`
    - Add private transient member:
      `mutable bool bInventoryFullOnLastCheck = false;` -- cached state for text override (mutable because CanInteract is const)

    **Implementation changes (PickupActor.cpp):**
    - Add include: `Inventory/InventoryComponent.h` (ItemDataAsset.h already included from Plan 01)

    - `CanInteract_Implementation`:
      1. Call `Super::CanInteract_Implementation(Interactor)` first, return false if base returns false
      2. Find UInventoryComponent on Interactor via FindComponentByClass
      3. If no component found, return true (graceful fallback -- Phase 1 behavior)
      4. If `Inventory->IsFull()`:
         - Check if item is stackable AND already exists in inventory (can still add to existing stack):
           `const UItemDataAsset* Data = Inventory->GetItemData(ItemId);`
           If Data && Data->bIsStackable && Inventory->HasItem(ItemId), return true (can stack)
         - Otherwise: set `bInventoryFullOnLastCheck = true`, return true (still allow interaction so the prompt shows, but OnInteract will fail gracefully). Per CONTEXT: "When inventory is full, the interaction prompt text changes to Inventory Full." So return true from CanInteract but change the text. The GetInteractionText override handles this.
      5. Set `bInventoryFullOnLastCheck = false`, return true

    - `GetInteractionText_Implementation`:
      - Override to check bInventoryFullOnLastCheck (set during CanInteract which runs every tick from InteractionComponent). If true, return NSLOCTEXT("Interaction", "InventoryFull", "Inventory Full"). Otherwise return Super (InteractionText).

    - `OnInteract_Implementation` (replace existing):
      1. Find UInventoryComponent on Interactor
      2. If no InventoryComponent, log warning and return (don't destroy)
      3. Call `Inventory->TryAddItem(ItemId, Quantity)`
      4. If returns true:
         - Log success
         - Destroy self if bDestroyOnPickup
      5. If returns false:
         - Log "Inventory full, cannot pick up"
         - Do NOT destroy (item stays in world)

    - `InitFromItemData` (MODIFY existing minimal version from Plan 01 -- expand it):
      Replace the existing minimal implementation with the full version:
      1. Set ItemId = InItemId
      2. Set Quantity = InQuantity
      3. If ItemData && ItemData->WorldMesh is valid:
         - Load mesh: `UStaticMesh* Mesh = ItemData->WorldMesh.LoadSynchronous()`
         - Set on MeshComponent: `MeshComponent->SetStaticMesh(Mesh)`
      4. Set InteractionText to item DisplayName or fallback to "Pick Up"
      5. Log the initialization

    Copyright header unchanged. Use LogSerene.
  </action>
  <verify>
    Run the UE build command:
    ```
    "C:\Program Files\Epic Games\UE_5.7\Engine\Binaries\DotNET\UnrealBuildTool\UnrealBuildTool.exe" ProjectWalkingSim Win64 Development -Project="C:\Unreal Projects\ProjectWalkingSim\ProjectWalkingSim.uproject" -WaitMutex -FromMsBuild
    ```
  </verify>
  <done>
    PickupActor::OnInteract calls TryAddItem and destroys only on success. CanInteract tracks inventory-full state. GetInteractionText returns "Inventory Full" when appropriate. InitFromItemData (originally minimal from Plan 01) now configures a spawned pickup's mesh and interaction text as well. Compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: DoorActor locked-door support</name>
  <files>
    Source/ProjectWalkingSim/Public/Interaction/DoorActor.h
    Source/ProjectWalkingSim/Private/Interaction/DoorActor.cpp
  </files>
  <action>
    Extend ADoorActor with optional key-lock mechanics.

    **Header changes (DoorActor.h):**
    - Add new properties (EditAnywhere, BlueprintReadWrite, Category = "Door"):
      - `FName RequiredItemId = NAME_None;` -- if NAME_None, door is not lockable
      - `bool bIsLocked = false;` -- set true in editor for doors that start locked. Move from private to protected.
    - Add new property (EditAnywhere, BlueprintReadOnly, Category = "Door"):
      - `FText LockedText;` -- text shown when locked (default: "Locked")
    - Add override declarations:
      - `virtual bool CanInteract_Implementation(AActor* Interactor) const override;`
      - `virtual FText GetInteractionText_Implementation() const override;`

    **Implementation changes (DoorActor.cpp):**
    - Add include: `Inventory/InventoryComponent.h`
    - Constructor: Add `LockedText = NSLOCTEXT("Interaction", "DoorLocked", "Locked");`

    - `CanInteract_Implementation`:
      1. If `!bCanBeInteracted` return false (base behavior)
      2. If `!bIsLocked` return true (unlocked doors always interactable)
      3. If locked: check interactor's InventoryComponent for RequiredItemId
         - `UInventoryComponent* Inv = Interactor->FindComponentByClass<UInventoryComponent>()`
         - If Inv && Inv->HasItem(RequiredItemId), return true (player has the key)
         - If player does not have the key, return true anyway BUT the interaction text will show "Locked". The interaction still triggers so the player gets feedback. Actually, per horror game convention: show "Locked" text but still allow interaction attempt. OnInteract will handle the locked case with a log message.
         - Return true always (player can attempt interaction on locked doors for feedback)

    - `GetInteractionText_Implementation`:
      1. If bIsLocked, return LockedText ("Locked")
      2. Otherwise return Super (existing Open/Close text)

    - `OnInteract_Implementation` (modify existing):
      1. If bIsLocked:
         a. Find InventoryComponent on Interactor
         b. If Inv && Inv->HasItem(RequiredItemId):
            - Call `Inv->RemoveItemByName(RequiredItemId)` to consume the key
            - Set `bIsLocked = false`
            - Log: "Door unlocked using [ItemId]"
            - Update InteractionText to "Open" (it was "Locked")
            - Fall through to existing open/close logic below
         c. Else (no key):
            - Log: "Door is locked, requires [RequiredItemId]"
            - Return early (don't open)
      2. Existing open/close toggle logic (unchanged):
         - `bIsOpen = !bIsOpen;`
         - Direction calculation, target angle, text update
         - The existing code at the bottom of OnInteract is the open/close logic

    Structure the implementation so the lock check is at the TOP of OnInteract, before the existing open/close toggle. If locked and no key, return early. If locked and has key, consume key, unlock, then fall through to open.

    Copyright header unchanged. Use LogSerene.
  </action>
  <verify>
    Run the UE build command:
    ```
    "C:\Program Files\Epic Games\UE_5.7\Engine\Binaries\DotNET\UnrealBuildTool\UnrealBuildTool.exe" ProjectWalkingSim Win64 Development -Project="C:\Unreal Projects\ProjectWalkingSim\ProjectWalkingSim.uproject" -WaitMutex -FromMsBuild
    ```
  </verify>
  <done>
    DoorActor has RequiredItemId and bIsLocked properties. CanInteract always returns true for locked doors (player gets feedback). GetInteractionText returns "Locked" when locked. OnInteract consumes key item and unlocks on first interaction if player has the key, otherwise logs and returns. Unlocked doors behave exactly as before. Compiles cleanly.
  </done>
</task>

</tasks>

<verification>
- PickupActor::OnInteract calls InventoryComponent::TryAddItem (not just logging)
- PickupActor only destroys on successful pickup, not when inventory is full
- PickupActor::GetInteractionText returns "Inventory Full" when appropriate
- PickupActor::InitFromItemData (extended from Plan 01 minimal version) sets ItemId, Quantity, loads WorldMesh, and updates InteractionText
- DoorActor has RequiredItemId, bIsLocked, LockedText properties
- DoorActor consumes key via RemoveItemByName on unlock
- DoorActor shows "Locked" text when locked, "Open"/"Close" when unlocked
- All existing Phase 1 behavior preserved for unlocked doors and normal pickups
- Full UE build succeeds
</verification>

<success_criteria>
PickupActor and DoorActor are fully integrated with the inventory system. Picking up items adds them to inventory. Locked doors require and consume key items. Both gracefully handle edge cases (no inventory component, full inventory, no key).
</success_criteria>

<output>
After completion, create `.planning/phases/02-inventory-system/02-03-SUMMARY.md`
</output>
