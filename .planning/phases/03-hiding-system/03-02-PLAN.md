---
phase: 03-hiding-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Source/ProjectWalkingSim/Public/Visibility/VisibilityScoreComponent.h
  - Source/ProjectWalkingSim/Private/Visibility/VisibilityScoreComponent.cpp
  - Source/ProjectWalkingSim/ProjectWalkingSim.Build.cs
autonomous: true

must_haves:
  truths:
    - "VisibilityScoreComponent samples ambient light at the player's position periodically"
    - "GetVisibilityScore() returns a float 0.0 (invisible) to 1.0 (fully visible)"
    - "Crouching reduces visibility score by configurable amount"
    - "SceneCapture does NOT run every frame -- only on a timer (0.25s default)"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/Visibility/VisibilityScoreComponent.h"
      provides: "UVisibilityScoreComponent with GetVisibilityScore(), PerformCapture()"
      contains: "UVisibilityScoreComponent"
    - path: "Source/ProjectWalkingSim/Private/Visibility/VisibilityScoreComponent.cpp"
      provides: "Light sampling via SceneCaptureComponent2D + ReadFloat16Pixels"
  key_links:
    - from: "VisibilityScoreComponent"
      to: "USceneCaptureComponent2D"
      via: "CaptureScene() on timer, ReadFloat16Pixels for luminance"
      pattern: "CaptureScene|ReadFloat16Pixels"
    - from: "VisibilityScoreComponent"
      to: "ASereneCharacter"
      via: "GetOwner() cast to read crouch state"
      pattern: "GetIsCrouching"
---

<objective>
Create the visibility score component that samples ambient light around the player and outputs a 0.0-1.0 score. This component is independent of the hiding system -- it always runs on the character and provides a value that AI perception (Phase 4) will read.

Purpose: HIDE-02 requires darkness concealment. This component quantifies how visible the player is based on actual scene lighting, making darkness a real gameplay tool.
Output: UVisibilityScoreComponent ready to attach to ASereneCharacter.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-hiding-system/03-RESEARCH.md

@Source/ProjectWalkingSim/Public/Player/SereneCharacter.h
@Source/ProjectWalkingSim/Private/Player/SereneCharacter.cpp
@Source/ProjectWalkingSim/ProjectWalkingSim.Build.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: VisibilityScoreComponent with SceneCapture light sampling</name>
  <files>
    Source/ProjectWalkingSim/Public/Visibility/VisibilityScoreComponent.h
    Source/ProjectWalkingSim/Private/Visibility/VisibilityScoreComponent.cpp
  </files>
  <action>
    Create `Source/ProjectWalkingSim/Public/Visibility/` and `Source/ProjectWalkingSim/Private/Visibility/` directories.

    **VisibilityScoreComponent.h:**
    - `UVisibilityScoreComponent : public UActorComponent` (not USceneComponent -- the SceneCaptureComponent2D is created as a child of the owning actor, not as a subobject of this component)
    - UCLASS with ClassGroup=(Custom), meta=(BlueprintSpawnableComponent)
    - Public API:
      - `float GetVisibilityScore() const;` (BlueprintCallable) -- returns the current score 0.0-1.0
      - `float GetRawLightLevel() const;` (BlueprintCallable) -- returns raw light level before modifiers (for debug)
      - `void SetHidingReduction(float Reduction);` (BlueprintCallable) -- called by HidingComponent when entering/exiting hiding spots
    - Protected/EditAnywhere config:
      - `float CaptureInterval = 0.25f;` -- seconds between light samples
      - `int32 CaptureResolution = 8;` -- pixels per side of render target (8x8 = 64 pixels)
      - `float MaxExpectedLuminance = 3.0f;` -- luminance value that maps to 1.0 visibility (tune per scene)
      - `float CrouchReduction = 0.15f;` -- visibility reduction while crouching
      - `float DefaultHidingReduction = 0.5f;` -- default hiding spot reduction (can be overridden per spot)
    - Private members:
      - `TObjectPtr<USceneCaptureComponent2D> SceneCapture;` -- the capture component
      - `TObjectPtr<UTextureRenderTarget2D> RenderTarget;` -- 8x8 render target
      - `FTimerHandle CaptureTimerHandle;`
      - `float VisibilityScore = 1.0f;` -- current computed score
      - `float RawLightLevel = 1.0f;` -- raw average luminance (before modifiers)
      - `float CurrentHidingReduction = 0.0f;` -- set by HidingComponent (0 when not hiding)
      - `void PerformCapture();` -- timer callback
      - `void ComputeScore();` -- extract pixels and compute score

    **VisibilityScoreComponent.cpp:**

    **Constructor:**
    - `PrimaryComponentTick.bCanEverTick = false;` -- no tick needed, uses timer
    - Do NOT create SceneCaptureComponent2D in constructor. Create it in BeginPlay because it needs the world and proper attachment.

    **BeginPlay:**
    1. Create `UTextureRenderTarget2D` via `NewObject<UTextureRenderTarget2D>(this)`:
       - `RenderTarget->InitAutoFormat(CaptureResolution, CaptureResolution);`
       - `RenderTarget->RenderTargetFormat = RTF_RGBA16f;` (HDR for accurate light values)
    2. Create `USceneCaptureComponent2D` via `NewObject<USceneCaptureComponent2D>(GetOwner(), ...)`
       - Register it: `SceneCapture->RegisterComponent()`
       - Attach to owner root: `SceneCapture->AttachToComponent(GetOwner()->GetRootComponent(), FAttachmentTransformRules::SnapToTargetNotIncludingScale)`
       - Configure:
         - `TextureTarget = RenderTarget;`
         - `CaptureSource = ESceneCaptureSource::SCS_FinalColorHDR;`
         - `bCaptureEveryFrame = false;`
         - `bCaptureOnMovement = false;`
         - `bAlwaysPersistRenderingState = true;`
       - ShowFlags optimization (disable expensive features not needed for brightness):
         - `ShowFlags.SetBloom(false);`
         - `ShowFlags.SetMotionBlur(false);`
         - `ShowFlags.SetParticles(false);`
         - `ShowFlags.SetSkeletalMeshes(false);`
         - `ShowFlags.SetFog(false);`
         - `ShowFlags.SetPostProcessing(false);` -- we want raw scene color, not tone-mapped
       - Lumen GI support (CRITICAL for correct light readings):
         - `ShowFlags.SetGlobalIllumination(true);`
         - `ShowFlags.SetReflectionEnvironment(true);`
       - Set a small FOV: `SceneCapture->FOVAngle = 90.0f;` (captures hemisphere above player)
    3. Start periodic timer:
       ```cpp
       GetWorld()->GetTimerManager().SetTimer(
           CaptureTimerHandle, this, &UVisibilityScoreComponent::PerformCapture,
           CaptureInterval, true);
       ```

    **PerformCapture:**
    1. Guard: `if (!SceneCapture || !RenderTarget) return;`
    2. Call `SceneCapture->CaptureScene();`
    3. Call `ComputeScore();`

    **ComputeScore:**
    1. Get render target resource: `FTextureRenderTargetResource* Resource = RenderTarget->GameThread_GetRenderTargetResource();`
    2. Guard: `if (!Resource) return;`
    3. Read pixels: `TArray<FFloat16Color> Pixels; Resource->ReadFloat16Pixels(Pixels);`
    4. Compute average luminance using Rec.709 coefficients:
       ```cpp
       float TotalLuminance = 0.0f;
       for (const FFloat16Color& Pixel : Pixels)
       {
           float R = Pixel.R.GetFloat();
           float G = Pixel.G.GetFloat();
           float B = Pixel.B.GetFloat();
           TotalLuminance += 0.2126f * R + 0.7152f * G + 0.0722f * B;
       }
       float AvgLuminance = (Pixels.Num() > 0) ? TotalLuminance / Pixels.Num() : 0.0f;
       ```
    5. Normalize: `RawLightLevel = FMath::Clamp(AvgLuminance / MaxExpectedLuminance, 0.0f, 1.0f);`
    6. Apply modifiers:
       ```cpp
       float Score = RawLightLevel;
       ACharacter* Character = Cast<ACharacter>(GetOwner());
       if (Character && Character->bIsCrouched)
       {
           Score -= CrouchReduction;
       }
       Score -= CurrentHidingReduction;
       VisibilityScore = FMath::Clamp(Score, 0.0f, 1.0f);
       ```
       NOTE: Use `Character->bIsCrouched` (the engine's built-in crouch state from CMC) rather than casting to ASereneCharacter. This avoids a circular dependency between Visibility/ and Player/ directories. If bIsCrouched is not accurate enough, cast to ASereneCharacter and call GetIsCrouching(), but add the forward declaration carefully.

    **SetHidingReduction:**
    - `CurrentHidingReduction = Reduction;` -- simple setter. HidingComponent calls this with the spot's HidingVisibilityReduction on enter, and 0.0f on exit.

    **EndPlay:**
    - Clear timer: `GetWorld()->GetTimerManager().ClearTimer(CaptureTimerHandle);`
    - Destroy SceneCapture if valid: `if (SceneCapture) { SceneCapture->DestroyComponent(); }`

    **Include requirements:**
    - `#include "Components/SceneCaptureComponent2D.h"`
    - `#include "Engine/TextureRenderTarget2D.h"`
    - `#include "GameFramework/Character.h"` (for bIsCrouched)
    - `#include "Core/SereneLogChannels.h"` for UE_LOG(LogSerene, ...)

    Add UE_LOG statements in BeginPlay (component initialized, capture resolution) and in ComputeScore (Verbose level: raw luminance, final score) for debugging.
  </action>
  <verify>
    Build compiles. Verify:
    - UVisibilityScoreComponent exists with GetVisibilityScore(), GetRawLightLevel(), SetHidingReduction()
    - bCaptureEveryFrame is false
    - Timer-based capture at CaptureInterval (0.25s default)
    - ShowFlags disable expensive features
    - ReadFloat16Pixels used for HDR pixel readback
  </verify>
  <done>
    UVisibilityScoreComponent compiles. Light sampling uses SceneCaptureComponent2D at 8x8 resolution on a 0.25s timer. Crouching and hiding reduce score. GetVisibilityScore() returns 0.0-1.0.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add RenderCore module dependency to Build.cs</name>
  <files>
    Source/ProjectWalkingSim/ProjectWalkingSim.Build.cs
  </files>
  <action>
    The VisibilityScoreComponent uses `UTextureRenderTarget2D` and `FFloat16Color` which require the `RenderCore` module. Also `USceneCaptureComponent2D` may need `Renderer` depending on the includes.

    Add `"RenderCore"` to `PublicDependencyModuleNames` in Build.cs. This module provides the render target and pixel format types.

    Check if `"RHI"` is also needed for FFloat16Color (it lives in RHI module). If so, add it too. The safest approach: add both `"RenderCore"` and `"RHI"` to PublicDependencyModuleNames.

    The resulting PublicDependencyModuleNames should be:
    ```csharp
    PublicDependencyModuleNames.AddRange(new string[] {
        "Core",
        "CoreUObject",
        "Engine",
        "InputCore",
        "EnhancedInput",
        "UMG",
        "GameplayTags",
        "PhysicsCore",
        "RenderCore",
        "RHI"
    });
    ```
  </action>
  <verify>
    Build.cs contains "RenderCore" and "RHI" in PublicDependencyModuleNames. Project compiles with VisibilityScoreComponent.
  </verify>
  <done>
    Build.cs updated with RenderCore and RHI module dependencies. VisibilityScoreComponent fully compiles.
  </done>
</task>

</tasks>

<verification>
- Project compiles with zero errors
- UVisibilityScoreComponent has GetVisibilityScore() returning float 0.0-1.0
- SceneCapture is NOT capturing every frame (bCaptureEveryFrame = false)
- Timer drives periodic capture at configurable interval
- Crouch and hiding modifiers reduce the score
- Build.cs has RenderCore and RHI dependencies
</verification>

<success_criteria>
VisibilityScoreComponent compiles and is ready to attach to ASereneCharacter. Light sampling pipeline is complete: capture -> read pixels -> compute luminance -> apply modifiers -> output score. AI perception (Phase 4) can call GetVisibilityScore() without knowing implementation details.
</success_criteria>

<output>
After completion, create `.planning/phases/03-hiding-system/03-02-SUMMARY.md`
</output>
