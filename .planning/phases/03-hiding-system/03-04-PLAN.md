---
phase: 03-hiding-system
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - Source/ProjectWalkingSim/Public/Hiding/HidingComponent.h
  - Source/ProjectWalkingSim/Private/Hiding/HidingComponent.cpp
autonomous: true

must_haves:
  truths:
    - "HidingComponent manages a 4-state machine: Free -> Entering -> Hidden -> Exiting -> Free"
    - "EnterHidingSpot disables movement, plays entry montage, blends camera to hiding spot"
    - "Montage completion delegates drive state transitions (not tick polling)"
    - "ExitHidingSpot plays exit montage, blends camera back, restores movement"
    - "Look constraints are set relative to hiding spot orientation (world-space yaw offset)"
    - "OnHidingStateChanged delegate broadcasts state changes to other systems"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/Hiding/HidingComponent.h"
      provides: "UHidingComponent with EnterHidingSpot, ExitHidingSpot, GetHidingState, IsHiding"
      contains: "UHidingComponent"
    - path: "Source/ProjectWalkingSim/Private/Hiding/HidingComponent.cpp"
      provides: "Full state machine: entry/exit montage, camera blend, look constraints, input context switch"
  key_links:
    - from: "HidingComponent.cpp"
      to: "AHidingSpotActor"
      via: "EnterHidingSpot receives AHidingSpotActor*, reads SpotData, blends to HidingCamera"
      pattern: "EnterHidingSpot.*AHidingSpotActor"
    - from: "HidingComponent.cpp"
      to: "APlayerController::SetViewTargetWithBlend"
      via: "Camera blend to hiding spot actor as view target"
      pattern: "SetViewTargetWithBlend"
    - from: "HidingComponent.cpp"
      to: "APlayerCameraManager"
      via: "ViewPitchMin/Max and ViewYawMin/Max for constrained look"
      pattern: "ViewPitchMin|ViewYawMin"
    - from: "HidingComponent.cpp"
      to: "UAnimInstance::Montage_Play"
      via: "Entry/exit animation playback with FOnMontageEnded delegate"
      pattern: "Montage_Play.*Montage_SetEndDelegate"
---

<objective>
Create the UHidingComponent that manages the full hiding lifecycle as a state machine on the player character. This is the core of the hiding system -- it orchestrates montage playback, camera transitions, movement locking, look constraint application, input context switching, and mesh visibility.

Purpose: This component is the player-side controller for all hiding behavior. Without it, interacting with a hiding spot does nothing.
Output: UHidingComponent with complete state machine from Free through Entering/Hidden/Exiting and back to Free.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-hiding-system/03-RESEARCH.md
@.planning/phases/03-hiding-system/03-01-SUMMARY.md

@Source/ProjectWalkingSim/Public/Hiding/HidingTypes.h
@Source/ProjectWalkingSim/Public/Hiding/HidingSpotDataAsset.h
@Source/ProjectWalkingSim/Public/Hiding/HidingSpotActor.h
@Source/ProjectWalkingSim/Public/Player/SereneCharacter.h
@Source/ProjectWalkingSim/Private/Player/SereneCharacter.cpp
@Source/ProjectWalkingSim/Public/Player/SerenePlayerController.h
@Source/ProjectWalkingSim/Public/Player/Components/InteractionComponent.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: HidingComponent state machine with montage and camera control</name>
  <files>
    Source/ProjectWalkingSim/Public/Hiding/HidingComponent.h
    Source/ProjectWalkingSim/Private/Hiding/HidingComponent.cpp
  </files>
  <action>
    **HidingComponent.h:**

    Create `UHidingComponent : public UActorComponent`.
    UCLASS with ClassGroup=(Custom), meta=(BlueprintSpawnableComponent).

    **Public API:**
    - `void EnterHidingSpot(AHidingSpotActor* Spot);` (BlueprintCallable) -- called by HidingSpotActor::OnInteract
    - `void ExitHidingSpot();` (BlueprintCallable) -- called by input action (exit key)
    - `EHidingState GetHidingState() const;` (BlueprintCallable) -- returns current state
    - `bool IsHiding() const;` (BlueprintCallable) -- returns true if state is Hidden
    - `bool IsInTransition() const;` (BlueprintCallable) -- returns true if Entering or Exiting
    - `AHidingSpotActor* GetCurrentHidingSpot() const;` (BlueprintCallable) -- returns current spot or nullptr

    **Delegate:**
    - `UPROPERTY(BlueprintAssignable) FOnHidingStateChanged OnHidingStateChanged;` -- declared in HidingTypes.h

    **Protected config (EditAnywhere):**
    - `TObjectPtr<UInputMappingContext> HidingMappingContext;` -- IMC for hiding (look + exit only). Assigned in BP subclass or DefaultObject.
    - `TObjectPtr<UInputAction> ExitHidingAction;` -- IA for exit key press. Assigned in BP.
    - `int32 HidingInputPriority = 1;` -- priority for the hiding IMC (higher than default 0)

    **Private members:**
    - `EHidingState HidingState = EHidingState::Free;`
    - `TWeakObjectPtr<AHidingSpotActor> CurrentHidingSpot;`
    - `float SavedViewPitchMin;` -- saved camera manager limits to restore
    - `float SavedViewPitchMax;`
    - `float SavedViewYawMin;`
    - `float SavedViewYawMax;`

    **Private methods:**
    - `void OnEntryMontageEnded(UAnimMontage* Montage, bool bInterrupted);`
    - `void OnExitMontageEnded(UAnimMontage* Montage, bool bInterrupted);`
    - `void TransitionToHiddenState();` -- called after entry montage completes
    - `void TransitionToFreeState();` -- called after exit montage completes
    - `void ApplyLookConstraints();` -- set ViewPitch/Yaw limits on camera manager
    - `void RestoreLookConstraints();` -- restore saved limits
    - `void DisablePlayerSystems();` -- disable movement, interaction, headbob, lean, footstep
    - `void RestorePlayerSystems();` -- re-enable all
    - `void HidePlayerMesh();` -- hide character mesh while in hiding spot
    - `void ShowPlayerMesh();` -- restore character mesh visibility
    - `void SwitchToHidingInputContext();` -- remove default IMC, add hiding IMC
    - `void RestoreDefaultInputContext();` -- reverse

    Forward declare: `class AHidingSpotActor; class UHidingSpotDataAsset; class UInputMappingContext; class UInputAction; class UAnimMontage;`

    **HidingComponent.cpp:**

    **Constructor:**
    - `PrimaryComponentTick.bCanEverTick = false;` -- no tick needed, event-driven

    **EnterHidingSpot(AHidingSpotActor* Spot):**
    1. Guard: `if (HidingState != EHidingState::Free) return;`
    2. Guard: `if (!Spot) return;`
    3. Check CanHide: `if (!IHideable::Execute_CanHide(Spot, GetOwner())) return;`
    4. Set state: `HidingState = EHidingState::Entering;`
    5. Store spot: `CurrentHidingSpot = Spot;`
    6. `DisablePlayerSystems();`
    7. Get SpotData: `UHidingSpotDataAsset* Data = IHideable::Execute_GetSpotData(Spot);`
    8. Play entry montage if available:
       ```cpp
       ACharacter* Character = Cast<ACharacter>(GetOwner());
       if (Data && Data->EntryMontage && Character && Character->GetMesh())
       {
           UAnimInstance* AnimInstance = Character->GetMesh()->GetAnimInstance();
           if (AnimInstance)
           {
               float Duration = AnimInstance->Montage_Play(Data->EntryMontage);
               if (Duration > 0.f)
               {
                   FOnMontageEnded EndDelegate;
                   EndDelegate.BindUObject(this, &UHidingComponent::OnEntryMontageEnded);
                   AnimInstance->Montage_SetEndDelegate(EndDelegate, Data->EntryMontage);
               }
               else
               {
                   // Montage failed to play -- skip directly to Hidden
                   TransitionToHiddenState();
               }
           }
           else
           {
               TransitionToHiddenState();
           }
       }
       else
       {
           // No montage -- skip directly to Hidden state
           TransitionToHiddenState();
       }
       ```
    9. Blend camera to hiding spot:
       ```cpp
       APlayerController* PC = Cast<APlayerController>(Character->GetController());
       if (PC && Data)
       {
           PC->SetViewTargetWithBlend(
               Spot,
               Data->CameraBlendInTime,
               VTBlend_Cubic,
               0.0f,
               false
           );
       }
       ```
    10. Notify hiding spot: `IHideable::Execute_OnEnterHiding(Spot, GetOwner());`
    11. Broadcast: `OnHidingStateChanged.Broadcast(EHidingState::Entering);`
    12. Log: UE_LOG(LogSerene, Log, "Entering hiding spot [%s]", *Spot->GetName());

    **OnEntryMontageEnded(UAnimMontage* Montage, bool bInterrupted):**
    - If interrupted: `TransitionToFreeState(); return;`
    - Otherwise: `TransitionToHiddenState();`

    **TransitionToHiddenState():**
    1. `HidingState = EHidingState::Hidden;`
    2. `HidePlayerMesh();`
    3. `ApplyLookConstraints();`
    4. `SwitchToHidingInputContext();`
    5. Set VisibilityScoreComponent hiding reduction:
       ```cpp
       UVisibilityScoreComponent* VisComp = GetOwner()->FindComponentByClass<UVisibilityScoreComponent>();
       if (VisComp && CurrentHidingSpot.IsValid())
       {
           UHidingSpotDataAsset* Data = IHideable::Execute_GetSpotData(CurrentHidingSpot.Get());
           if (Data)
           {
               VisComp->SetHidingReduction(Data->HidingVisibilityReduction);
           }
       }
       ```
    6. `OnHidingStateChanged.Broadcast(EHidingState::Hidden);`
    7. UE_LOG(LogSerene, Log, "Now hidden in [%s]", *CurrentHidingSpot->GetName());

    **ExitHidingSpot():**
    1. Guard: `if (HidingState != EHidingState::Hidden) return;`
    2. `HidingState = EHidingState::Exiting;`
    3. `RestoreLookConstraints();`
    4. `RestoreDefaultInputContext();`
    5. `ShowPlayerMesh();`
    6. Clear visibility reduction: `if (auto* VisComp = GetOwner()->FindComponentByClass<UVisibilityScoreComponent>()) VisComp->SetHidingReduction(0.0f);`
    7. Get SpotData, play exit montage (same pattern as entry):
       ```cpp
       if (Data && Data->ExitMontage && AnimInstance)
       {
           float Duration = AnimInstance->Montage_Play(Data->ExitMontage);
           if (Duration > 0.f)
           {
               FOnMontageEnded EndDelegate;
               EndDelegate.BindUObject(this, &UHidingComponent::OnExitMontageEnded);
               AnimInstance->Montage_SetEndDelegate(EndDelegate, Data->ExitMontage);
           }
           else { TransitionToFreeState(); }
       }
       else { TransitionToFreeState(); }
       ```
    8. Blend camera back to player character:
       ```cpp
       ACharacter* Character = Cast<ACharacter>(GetOwner());
       APlayerController* PC = Cast<APlayerController>(Character->GetController());
       if (PC && Data)
       {
           PC->SetViewTargetWithBlend(
               Character,  // Back to the character (FirstPersonCamera)
               Data->CameraBlendOutTime,
               VTBlend_Cubic,
               0.0f,
               false
           );
       }
       ```
    9. Notify hiding spot: `IHideable::Execute_OnExitHiding(CurrentHidingSpot.Get(), GetOwner());`
    10. `OnHidingStateChanged.Broadcast(EHidingState::Exiting);`

    **OnExitMontageEnded:**
    - `TransitionToFreeState();` (handle interruption the same way -- just go to Free)

    **TransitionToFreeState():**
    1. `HidingState = EHidingState::Free;`
    2. `CurrentHidingSpot = nullptr;`
    3. `RestorePlayerSystems();`
    4. `OnHidingStateChanged.Broadcast(EHidingState::Free);`
    5. UE_LOG(LogSerene, Log, "Exited hiding spot, now Free");

    **ApplyLookConstraints():**
    ```cpp
    ACharacter* Character = Cast<ACharacter>(GetOwner());
    APlayerController* PC = Cast<APlayerController>(Character->GetController());
    if (!PC || !PC->PlayerCameraManager) return;

    APlayerCameraManager* CamMgr = PC->PlayerCameraManager;

    // Save current limits
    SavedViewPitchMin = CamMgr->ViewPitchMin;
    SavedViewPitchMax = CamMgr->ViewPitchMax;
    SavedViewYawMin = CamMgr->ViewYawMin;
    SavedViewYawMax = CamMgr->ViewYawMax;

    UHidingSpotDataAsset* Data = IHideable::Execute_GetSpotData(CurrentHidingSpot.Get());
    if (!Data) return;

    // Pitch: absolute values (same regardless of spot orientation)
    CamMgr->ViewPitchMin = Data->ViewPitchMin;
    CamMgr->ViewPitchMax = Data->ViewPitchMax;

    // Yaw: RELATIVE to hiding spot's world yaw (CRITICAL -- see Research Pitfall 3)
    float SpotYaw = CurrentHidingSpot->GetActorRotation().Yaw;
    CamMgr->ViewYawMin = SpotYaw + Data->ViewYawMin;
    CamMgr->ViewYawMax = SpotYaw + Data->ViewYawMax;
    ```

    **RestoreLookConstraints():**
    ```cpp
    ACharacter* Character = Cast<ACharacter>(GetOwner());
    APlayerController* PC = Cast<APlayerController>(Character->GetController());
    if (!PC || !PC->PlayerCameraManager) return;

    APlayerCameraManager* CamMgr = PC->PlayerCameraManager;
    CamMgr->ViewPitchMin = SavedViewPitchMin;
    CamMgr->ViewPitchMax = SavedViewPitchMax;
    CamMgr->ViewYawMin = SavedViewYawMin;
    CamMgr->ViewYawMax = SavedViewYawMax;
    ```

    **DisablePlayerSystems():**
    ```cpp
    ACharacter* Character = Cast<ACharacter>(GetOwner());
    if (!Character) return;

    // Freeze movement
    Character->GetCharacterMovement()->SetMovementMode(MOVE_None);

    // Disable interaction trace (prevent interacting with other objects during transition)
    if (UInteractionComponent* IC = Character->FindComponentByClass<UInteractionComponent>())
    {
        IC->SetComponentTickEnabled(false);
    }

    // Disable headbob, lean, footstep (they read movement state and should be quiet)
    if (UHeadBobComponent* HB = Character->FindComponentByClass<UHeadBobComponent>())
    {
        HB->SetComponentTickEnabled(false);
    }
    if (ULeanComponent* Lean = Character->FindComponentByClass<ULeanComponent>())
    {
        Lean->SetComponentTickEnabled(false);
    }
    if (UFootstepComponent* FS = Character->FindComponentByClass<UFootstepComponent>())
    {
        FS->SetComponentTickEnabled(false);
    }
    ```

    **RestorePlayerSystems():**
    Reverse of DisablePlayerSystems:
    - `CMC->SetMovementMode(MOVE_Walking);`
    - Re-enable ticking on InteractionComponent, HeadBobComponent, LeanComponent, FootstepComponent.

    **HidePlayerMesh() / ShowPlayerMesh():**
    ```cpp
    ACharacter* Character = Cast<ACharacter>(GetOwner());
    if (!Character) return;

    // Main mesh
    Character->GetMesh()->SetVisibility(bShow);

    // WorldRepresentationMesh (shadow mesh) -- find by name since it's not exposed via getter
    // Actually, ASereneCharacter has it as a protected member. Use FindComponentByClass<USkeletalMeshComponent>
    // with tag check, or better: just hide ALL skeletal mesh components on the character.
    // Simplest approach: iterate over components.
    TArray<USkeletalMeshComponent*> SkMeshes;
    Character->GetComponents<USkeletalMeshComponent>(SkMeshes);
    for (USkeletalMeshComponent* Mesh : SkMeshes)
    {
        Mesh->SetVisibility(bShow);
    }
    ```
    Use a single helper: `void SetPlayerMeshVisibility(bool bVisible);` called by both HidePlayerMesh and ShowPlayerMesh.

    **SwitchToHidingInputContext():**
    ```cpp
    ACharacter* Character = Cast<ACharacter>(GetOwner());
    APlayerController* PC = Cast<APlayerController>(Character->GetController());
    if (!PC) return;

    UEnhancedInputLocalPlayerSubsystem* Subsystem =
        ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PC->GetLocalPlayer());
    if (!Subsystem) return;

    // Don't remove default context -- just add hiding at higher priority
    // This way Look still works (it's in both contexts)
    // But movement, interact, lean are overridden by hiding context which doesn't have them
    // Actually, removing default is cleaner to prevent any unintended input
    // DECISION: Remove default, add hiding. Cleaner isolation.
    if (ASerenePlayerController* SPC = Cast<ASerenePlayerController>(PC))
    {
        // Access DefaultMappingContext -- it's protected. Use the subsystem to remove by reference.
        // Problem: DefaultMappingContext is protected on SPC.
        // Solution: Store a reference to the default IMC on HidingComponent itself (assign in BP alongside HidingMappingContext)
        // OR: Have HidingComponent store the default IMC reference as a config property.
    }
    // Simpler approach: Store DefaultMappingContext as a config UPROPERTY on HidingComponent.
    // Level designer (or BP subclass) assigns both DefaultMappingContext and HidingMappingContext.
    ```

    Add to HidingComponent.h protected config:
    - `TObjectPtr<UInputMappingContext> DefaultMappingContext;` -- the default IMC to remove/restore. Assigned in BP.

    Then SwitchToHidingInputContext:
    ```cpp
    if (DefaultMappingContext) Subsystem->RemoveMappingContext(DefaultMappingContext);
    if (HidingMappingContext) Subsystem->AddMappingContext(HidingMappingContext, HidingInputPriority);
    ```

    RestoreDefaultInputContext:
    ```cpp
    if (HidingMappingContext) Subsystem->RemoveMappingContext(HidingMappingContext);
    if (DefaultMappingContext) Subsystem->AddMappingContext(DefaultMappingContext, 0);
    ```

    **SetupInputComponent override on the component? No.** Input binding for ExitHidingAction should be done via BeginPlay:
    ```cpp
    void UHidingComponent::BeginPlay()
    {
        Super::BeginPlay();

        // Bind exit input -- this binding persists but only fires when HidingMappingContext is active
        ACharacter* Character = Cast<ACharacter>(GetOwner());
        if (!Character) return;

        APlayerController* PC = Cast<APlayerController>(Character->GetController());
        if (!PC) return;

        UEnhancedInputComponent* EIC = Cast<UEnhancedInputComponent>(PC->InputComponent);
        if (EIC && ExitHidingAction)
        {
            EIC->BindAction(ExitHidingAction, ETriggerEvent::Started, this, &UHidingComponent::ExitHidingSpot);
        }
    }
    ```
    NOTE: The binding always exists, but ExitHidingAction only fires when HidingMappingContext is active (because the mapping is in the hiding IMC). This is the correct Enhanced Input pattern.

    **Includes in .cpp:**
    - HidingComponent.h
    - Hiding/HidingSpotActor.h
    - Hiding/HidingSpotDataAsset.h
    - Hiding/HidingTypes.h
    - Interaction/HideableInterface.h
    - Visibility/VisibilityScoreComponent.h
    - Player/Components/InteractionComponent.h
    - Player/Components/HeadBobComponent.h
    - Player/Components/LeanComponent.h
    - Player/Components/FootstepComponent.h
    - GameFramework/CharacterMovementComponent.h
    - Camera/PlayerCameraManager.h
    - EnhancedInputComponent.h
    - EnhancedInputSubsystems.h
    - Animation/AnimInstance.h
    - Animation/AnimMontage.h
    - Core/SereneLogChannels.h
  </action>
  <verify>
    Build compiles. Verify:
    - EHidingState transitions: Free->Entering->Hidden->Exiting->Free
    - EnterHidingSpot plays montage, blends camera, disables movement
    - Montage_SetEndDelegate called AFTER Montage_Play (pitfall #2)
    - ViewYawMin/Max computed relative to spot world yaw (pitfall #3)
    - SetViewTargetWithBlend used for camera (not manual lerp)
    - DisablePlayerSystems disables CMC, interaction, headbob, lean, footstep
    - RestorePlayerSystems re-enables them all
    - Input context switching removes default, adds hiding, reverses on exit
  </verify>
  <done>
    UHidingComponent compiles with complete 4-state machine. Entry plays montage + blends camera + disables systems. Hidden state applies look constraints + input context. Exit reverses everything. All camera work uses SetViewTargetWithBlend. Montage completion uses delegates (not polling).
  </done>
</task>

</tasks>

<verification>
- Project compiles with zero errors
- HidingComponent has EnterHidingSpot, ExitHidingSpot, GetHidingState, IsHiding
- State transitions: Free -> Entering (on interact) -> Hidden (on montage end) -> Exiting (on exit input) -> Free (on montage end)
- Camera blending uses SetViewTargetWithBlend (not manual lerp)
- Look constraints computed relative to hiding spot world yaw
- Montage delegates bound AFTER Montage_Play
- Movement mode set to MOVE_None during hiding, MOVE_Walking on exit
- Player mesh hidden during Hidden state
</verification>

<success_criteria>
The HidingComponent fully manages the hiding lifecycle. A player interacting with a HidingSpotActor triggers the full flow: movement freeze, montage play, camera blend, mesh hide, look constraint, input context switch. Exiting reverses everything cleanly.
</success_criteria>

<output>
After completion, create `.planning/phases/03-hiding-system/03-04-SUMMARY.md`
</output>
