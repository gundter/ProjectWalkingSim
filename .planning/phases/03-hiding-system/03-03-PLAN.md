---
phase: 03-hiding-system
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - Source/ProjectWalkingSim/Public/Hiding/HidingSpotActor.h
  - Source/ProjectWalkingSim/Private/Hiding/HidingSpotActor.cpp
autonomous: true

must_haves:
  truths:
    - "AHidingSpotActor implements both IInteractable and IHideable interfaces"
    - "Hiding spot has a UCameraComponent positioned for the hidden view"
    - "Interaction text comes from the HidingSpotDataAsset (e.g. 'Hide in Locker')"
    - "Spot tracks occupancy (bIsOccupied) and monster discovery (bDiscoveredByMonster)"
    - "OnInteract delegates to the player's HidingComponent via EnterHidingSpot()"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/Hiding/HidingSpotActor.h"
      provides: "AHidingSpotActor base class implementing IInteractable + IHideable"
      contains: "AHidingSpotActor"
    - path: "Source/ProjectWalkingSim/Private/Hiding/HidingSpotActor.cpp"
      provides: "Full IInteractable and IHideable implementations"
  key_links:
    - from: "HidingSpotActor.h"
      to: "HidingSpotDataAsset.h"
      via: "UPROPERTY(EditAnywhere) UHidingSpotDataAsset* SpotData"
      pattern: "UHidingSpotDataAsset.*SpotData"
    - from: "HidingSpotActor.cpp"
      to: "HidingComponent"
      via: "OnInteract calls HidingComp->EnterHidingSpot(this)"
      pattern: "EnterHidingSpot"
    - from: "HidingSpotActor.h"
      to: "InteractableInterface.h"
      via: "implements IInteractable"
      pattern: "public IInteractable"
    - from: "HidingSpotActor.h"
      to: "HideableInterface.h"
      via: "implements IHideable"
      pattern: "public IHideable"
---

<objective>
Create the base AHidingSpotActor that implements both IInteractable and IHideable. This is the placeable actor that level designers drop into the world -- it provides a trigger volume, hiding camera, and data asset reference. Interaction delegates to the player's HidingComponent.

Purpose: Without the hiding spot actor, there is nothing to interact with. This actor is the world-side half of the hiding system (the other half is the player's HidingComponent).
Output: AHidingSpotActor base class ready for level placement.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-hiding-system/03-RESEARCH.md
@.planning/phases/03-hiding-system/03-01-SUMMARY.md

@Source/ProjectWalkingSim/Public/Interaction/InteractableInterface.h
@Source/ProjectWalkingSim/Public/Interaction/HideableInterface.h
@Source/ProjectWalkingSim/Public/Hiding/HidingSpotDataAsset.h
@Source/ProjectWalkingSim/Public/Hiding/HidingTypes.h
@Source/ProjectWalkingSim/Public/Player/SereneCharacter.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: AHidingSpotActor base class with dual interface implementation</name>
  <files>
    Source/ProjectWalkingSim/Public/Hiding/HidingSpotActor.h
    Source/ProjectWalkingSim/Private/Hiding/HidingSpotActor.cpp
  </files>
  <action>
    **HidingSpotActor.h:**

    Create `AHidingSpotActor : public AActor, public IInteractable, public IHideable`.
    UCLASS() -- NOT Abstract. We want a single concrete base class. Per-type visual differences are data-driven via UHidingSpotDataAsset, not subclasses. Three distinct data assets (locker, closet, under-bed) provide different montages, camera limits, and peek materials.

    **Components (created in constructor):**
    - `USceneComponent* SceneRoot` -- DefaultSceneRoot for transform
    - `UStaticMeshComponent* SpotMesh` -- Visual mesh (locker, closet, bed). EditAnywhere so level designers can assign per-instance. Can also be a USkeletalMeshComponent if the spot has an animated door, but start with StaticMesh and note that a future enhancement could swap to Skeletal for door animations.
    - `UBoxComponent* InteractionTrigger` -- Trigger volume that defines the approach area. Sized via EditAnywhere. Used only for spatial awareness (the actual interaction detection is the player's InteractionComponent line trace, not overlap). This box should have collision set to `ECollisionEnabled::QueryOnly` with a custom profile or just Visibility channel response. Actually, since InteractionComponent uses a line trace against Visibility channel, the SpotMesh itself serves as the trace target. The InteractionTrigger can be omitted for now -- the mesh IS the interaction target. Include the BoxComponent only if you want an extended interaction range beyond the mesh bounds. Decision: SKIP the BoxComponent. The SpotMesh provides the trace hit surface. Keep the actor simple.
    - `UCameraComponent* HidingCamera` -- The camera the player views from while hidden. Position/rotation set by the level designer in the editor. VisibleAnywhere, BlueprintReadOnly.
    - `UPostProcessComponent* PeekPostProcess` -- Applies the peek overlay (locker slats, closet crack). Configured at runtime from SpotData->PeekOverlayMaterial. Alternatively, apply via camera's PostProcessSettings. Decision: Use the HidingCamera's PostProcessSettings.WeightedBlendables instead of a separate component. This avoids an extra component. Set this up in BeginPlay.

    **Properties:**
    - `UPROPERTY(EditAnywhere, Category = "Hiding") TObjectPtr<UHidingSpotDataAsset> SpotData;` -- assign in editor per instance
    - `UPROPERTY(VisibleAnywhere, Category = "Hiding") bool bIsOccupied = false;`
    - `UPROPERTY(SaveGame) bool bDiscoveredByMonster = false;` -- persists with save system
    - `TWeakObjectPtr<AActor> OccupantActor;` -- who is hiding here (if occupied)

    **IInteractable implementation (_Implementation suffix for BlueprintNativeEvent):**

    - `GetInteractionText_Implementation()`: Return `SpotData->InteractionText` if SpotData is valid, otherwise FText::FromString("Hide"). If bIsOccupied, return empty FText (can't interact).
    - `CanInteract_Implementation(AActor* Interactor)`: Return `!bIsOccupied && SpotData != nullptr`. Also check that the Interactor's HidingComponent is in Free state (forward declare UHidingComponent, FindComponentByClass at runtime).
    - `OnInteract_Implementation(AActor* Interactor)`:
      1. Guard: `if (bIsOccupied) return;`
      2. Cast Interactor to ASereneCharacter (or AActor and use FindComponentByClass).
      3. Find UHidingComponent on the interactor: `UHidingComponent* HidingComp = Interactor->FindComponentByClass<UHidingComponent>();`
      4. Guard: `if (!HidingComp) return;`
      5. Call `HidingComp->EnterHidingSpot(this);` -- the HidingComponent drives the full flow.
      6. NOTE: Do NOT set bIsOccupied here. The HidingComponent will call OnEnterHiding which sets it.
    - `OnFocusBegin_Implementation(AActor* Interactor)`: Empty (no highlight effect needed for hiding spots -- they're environmental furniture).
    - `OnFocusEnd_Implementation(AActor* Interactor)`: Empty.

    **IHideable implementation:**

    - `CanHide_Implementation(AActor* HidingActor)`: Return `!bIsOccupied`.
    - `OnEnterHiding_Implementation(AActor* HidingActor)`:
      1. `bIsOccupied = true;`
      2. `OccupantActor = HidingActor;`
      3. UE_LOG(LogSerene, Log, "HidingSpot [%s] occupied by [%s]", *GetName(), *HidingActor->GetName());
    - `OnExitHiding_Implementation(AActor* HidingActor)`:
      1. `bIsOccupied = false;`
      2. `OccupantActor = nullptr;`
      3. UE_LOG(LogSerene, Log, "HidingSpot [%s] vacated", *GetName());
    - `GetHidingCamera_Implementation()`: Return `HidingCamera`.
    - `GetSpotData_Implementation()`: Return `SpotData`.
    - `IsOccupied_Implementation()`: Return `bIsOccupied`.
    - `MarkDiscovered_Implementation()`: `bDiscoveredByMonster = true;` + UE_LOG.
    - `WasDiscovered_Implementation()`: Return `bDiscoveredByMonster`.

    **BeginPlay:**
    - If SpotData and SpotData->PeekOverlayMaterial, add the material to HidingCamera's PostProcessSettings.WeightedBlendables:
      ```cpp
      if (SpotData && SpotData->PeekOverlayMaterial && HidingCamera)
      {
          FPostProcessSettings& PP = HidingCamera->PostProcessSettings;
          PP.bOverride_WeightedBlendables = true;  // not needed, WeightedBlendables always active
          FWeightedBlendable Blendable;
          Blendable.Weight = 1.0f;
          Blendable.Object = SpotData->PeekOverlayMaterial;
          PP.WeightedBlendables.Array.Add(Blendable);
      }
      ```
    - Log SpotData name and type tag if valid.

    **Constructor:**
    - Create SceneRoot, attach SpotMesh and HidingCamera to it.
    - SpotMesh: `SetCollisionProfileName(TEXT("BlockAll"))` so the interaction trace can hit it.
    - HidingCamera: `bAutoActivate = false;` (it is not the active camera until SetViewTargetWithBlend)

    **Include forward declarations carefully:**
    - Forward declare `class UHidingComponent;` in the .h file (do NOT include HidingComponent.h to avoid circular dependency). Include it in the .cpp.
    - Include InteractableInterface.h, HideableInterface.h, HidingSpotDataAsset.h in the .h file (needed for interface inheritance and SpotData property).
  </action>
  <verify>
    Build compiles. Verify:
    - AHidingSpotActor appears in Unreal class hierarchy (is a valid placeable actor)
    - Has SpotMesh (UStaticMeshComponent), HidingCamera (UCameraComponent)
    - Implements all 5 IInteractable methods and all 8 IHideable methods
    - OnInteract calls FindComponentByClass UHidingComponent and EnterHidingSpot
    - bDiscoveredByMonster has SaveGame metadata
  </verify>
  <done>
    AHidingSpotActor compiles with dual IInteractable + IHideable interface. Interaction delegates to HidingComponent. Camera and peek post-process configured from SpotData. Occupancy and monster discovery tracked.
  </done>
</task>

</tasks>

<verification>
- Project compiles with zero errors
- AHidingSpotActor inherits AActor, IInteractable, IHideable
- All interface methods have _Implementation versions
- OnInteract finds HidingComponent and calls EnterHidingSpot
- SpotData reference is EditAnywhere for per-instance assignment
- HidingCamera is a UCameraComponent with bAutoActivate = false
- Peek overlay material applied via HidingCamera PostProcessSettings in BeginPlay
</verification>

<success_criteria>
AHidingSpotActor is a concrete, placeable actor class. Level designers can drop it in, assign a SpotData asset, position the HidingCamera, and assign a mesh. The interaction flow is wired: player traces -> CanInteract -> OnInteract -> HidingComponent->EnterHidingSpot.
</success_criteria>

<output>
After completion, create `.planning/phases/03-hiding-system/03-03-SUMMARY.md`
</output>
