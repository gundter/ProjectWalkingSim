---
phase: 01-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - Source/ProjectWalkingSim/Public/Player/Components/InteractionComponent.h
  - Source/ProjectWalkingSim/Private/Player/Components/InteractionComponent.cpp
  - Source/ProjectWalkingSim/Public/Player/HUD/InteractionPromptWidget.h
  - Source/ProjectWalkingSim/Private/Player/HUD/InteractionPromptWidget.cpp
  - Source/ProjectWalkingSim/Public/Interaction/InteractableBase.h
  - Source/ProjectWalkingSim/Private/Interaction/InteractableBase.cpp
  - Source/ProjectWalkingSim/Public/Interaction/DoorActor.h
  - Source/ProjectWalkingSim/Private/Interaction/DoorActor.cpp
  - Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
  - Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
  - Source/ProjectWalkingSim/Public/Interaction/ReadableActor.h
  - Source/ProjectWalkingSim/Private/Interaction/ReadableActor.cpp
  - Source/ProjectWalkingSim/Public/Interaction/DrawerActor.h
  - Source/ProjectWalkingSim/Private/Interaction/DrawerActor.cpp
autonomous: true

must_haves:
  truths:
    - "Player can look at a door and see an interaction prompt appear"
    - "Player can press E to open/close the door"
    - "Player can look at a pickup item and see its name in a prompt"
    - "Player can look at a readable and see 'Read' prompt"
    - "Player can look at a drawer and see 'Open' prompt"
    - "Interaction prompt disappears when looking away from interactable objects"
    - "Interaction only triggers within ~1.5m range"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/Player/Components/InteractionComponent.h"
      provides: "Line trace detection + focus management + prompt dispatch"
      contains: "UInteractionComponent"
    - path: "Source/ProjectWalkingSim/Public/Interaction/InteractableBase.h"
      provides: "Base actor implementing IInteractable with common functionality"
      contains: "AInteractableBase"
    - path: "Source/ProjectWalkingSim/Public/Interaction/DoorActor.h"
      provides: "Animated door interactable"
      contains: "ADoorActor"
    - path: "Source/ProjectWalkingSim/Public/Interaction/PickupActor.h"
      provides: "Generic pickup actor for Phase 2 inventory integration"
      contains: "APickupActor"
    - path: "Source/ProjectWalkingSim/Public/Player/HUD/InteractionPromptWidget.h"
      provides: "HUD widget showing interaction text"
      contains: "UInteractionPromptWidget"
  key_links:
    - from: "InteractionComponent::PerformTrace"
      to: "IInteractable"
      via: "ImplementsInterface check on hit actor"
      pattern: "ImplementsInterface.*UInteractable"
    - from: "InteractionComponent::TryInteract"
      to: "IInteractable::Execute_OnInteract"
      via: "Interface Execute_ wrapper call"
      pattern: "Execute_OnInteract"
    - from: "InteractionComponent::OnInteractableChanged"
      to: "InteractionPromptWidget"
      via: "Delegate broadcast updates widget text and visibility"
      pattern: "OnInteractableChanged"
    - from: "DoorActor/PickupActor/ReadableActor/DrawerActor"
      to: "IInteractable"
      via: "Interface implementation on each actor"
      pattern: "class.*public.*IInteractable"
---

<objective>
Complete interaction system: line-trace detection component, HUD prompt widget, and four interactable actor types (door, pickup, readable, drawer).

Purpose: PLYR-04 is the interaction requirement. The player must be able to approach objects and see prompts appear, then interact with them. This is also the foundation for Phase 2 inventory (pickup actors) and Phase 3 hiding (hideable actors extend this pattern).

Output: InteractionComponent on the player that traces from camera, detects IInteractable actors, and displays a HUD prompt. Four actor types that implement IInteractable with distinct behaviors (door opens/closes, pickup logs pickup event, readable shows text, drawer slides open).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InteractionComponent and InteractionPromptWidget</name>
  <files>
    Source/ProjectWalkingSim/Public/Player/Components/InteractionComponent.h
    Source/ProjectWalkingSim/Private/Player/Components/InteractionComponent.cpp
    Source/ProjectWalkingSim/Public/Player/HUD/InteractionPromptWidget.h
    Source/ProjectWalkingSim/Private/Player/HUD/InteractionPromptWidget.cpp
  </files>
  <action>
    **InteractionComponent (.h):**
    - UInteractionComponent : public UActorComponent
    - ClassGroup=(Custom), meta=(BlueprintSpawnableComponent)
    - Tuning UPROPERTY(EditAnywhere, Category="Interaction"):
      - float InteractionRange = 150.0f (~1.5m)
      - TEnumAsByte of ECollisionChannel TraceChannel = ECC_Visibility
    - Delegate:
      - DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnInteractableChanged, AActor*, NewInteractable, FText, InteractionText)
      - UPROPERTY(BlueprintAssignable) FOnInteractableChanged OnInteractableChanged
    - Private:
      - TWeakObjectPtr of AActor CurrentInteractable
      - void PerformTrace()
      - void SetCurrentInteractable(AActor* NewInteractable)
    - Public:
      - void TryInteract() -- called from PlayerController on E press
      - AActor* GetCurrentInteractable() const

    **InteractionComponent (.cpp):**
    - TickComponent: call PerformTrace() every tick
    - PerformTrace (follow RESEARCH.md code example exactly):
      - Get PlayerController from owner pawn
      - GetPlayerViewPoint(ViewLocation, ViewRotation) -- trace from CAMERA, not capsule center (Pitfall 5!)
      - TraceEnd = ViewLocation + ViewRotation.Vector() * InteractionRange
      - LineTraceSingleByChannel with collision params (ignore owner)
      - If hit actor implements UInteractable::StaticClass():
        - If IInteractable::Execute_CanInteract(HitActor, GetOwner()) returns true:
          - Call SetCurrentInteractable(HitActor)
          - return
      - Call SetCurrentInteractable(nullptr)
    - SetCurrentInteractable:
      - If NewInteractable == CurrentInteractable: return (no change)
      - If CurrentInteractable valid: Execute_OnFocusEnd on old target
      - Update CurrentInteractable
      - If new target valid: Execute_OnFocusBegin on new target
      - Get interaction text: Execute_GetInteractionText if valid, else empty
      - Broadcast OnInteractableChanged(NewInteractable, InteractionText)
    - TryInteract:
      - If CurrentInteractable valid and Execute_CanInteract returns true:
        - Execute_OnInteract(CurrentInteractable, GetOwner())
        - Log with LogSerene: "Interacted with: {ActorName}"

    **InteractionPromptWidget (.h):**
    - UInteractionPromptWidget : public UUserWidget
    - UPROPERTY(meta=(BindWidget)) TObjectPtr of UTextBlock PromptText
    - UPROPERTY(meta=(BindWidget)) TObjectPtr of UTextBlock ReticleText (the dot)
    - UFUNCTION(BlueprintCallable) void UpdatePrompt(AActor* Interactable, const FText& Text)
    - UFUNCTION(BlueprintCallable) void HidePrompt()

    **InteractionPromptWidget (.cpp):**
    - UpdatePrompt:
      - If Interactable is valid and Text is not empty:
        - Set PromptText to format "E: {Text}" (e.g., "E: Open")
        - Show PromptText (SetVisibility Visible)
        - Project interactable world location to screen, position prompt near it
        - OR simpler approach: show prompt at fixed screen position (bottom center)
      - Else: HidePrompt()
    - HidePrompt:
      - Set PromptText visibility to Hidden/Collapsed

    NOTE: The widget requires a UMG Blueprint counterpart (WBP_InteractionPrompt) to be created in the editor with the TextBlock widgets named "PromptText" and "ReticleText" matching the BindWidget meta. The C++ class defines the logic; the UMG Blueprint defines the layout. Document this clearly in a comment.

    The two-stage prompt behavior from CONTEXT.md (reticle dot fades, then world-space prompt appears) is a VISUAL POLISH detail. For Phase 1, implement the simpler version: prompt text appears/disappears based on trace hit. The fade behavior can be refined later.

    IMPORTANT: Use GetPlayerViewPoint for trace origin, NOT GetActorLocation (Pitfall 5).
    IMPORTANT: Include "Interaction/InteractableInterface.h" to use Execute_ wrappers.
  </action>
  <verify>
    Component compiles. Widget C++ class compiles. InteractionComponent can be added to character in editor. OnInteractableChanged delegate visible in Blueprint.
  </verify>
  <done>
    InteractionComponent traces from camera center every tick at 150cm range. Detects IInteractable actors, manages focus state (OnFocusBegin/End), and broadcasts interaction text changes via delegate. TryInteract executes OnInteract on the focused actor. InteractionPromptWidget C++ base class ready for UMG Blueprint layout.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create InteractableBase and four interactable actor types</name>
  <files>
    Source/ProjectWalkingSim/Public/Interaction/InteractableBase.h
    Source/ProjectWalkingSim/Private/Interaction/InteractableBase.cpp
    Source/ProjectWalkingSim/Public/Interaction/DoorActor.h
    Source/ProjectWalkingSim/Private/Interaction/DoorActor.cpp
    Source/ProjectWalkingSim/Public/Interaction/PickupActor.h
    Source/ProjectWalkingSim/Private/Interaction/PickupActor.cpp
    Source/ProjectWalkingSim/Public/Interaction/ReadableActor.h
    Source/ProjectWalkingSim/Private/Interaction/ReadableActor.cpp
    Source/ProjectWalkingSim/Public/Interaction/DrawerActor.h
    Source/ProjectWalkingSim/Private/Interaction/DrawerActor.cpp
  </files>
  <action>
    **InteractableBase (.h/.cpp):**
    - AInteractableBase : public AActor, public IInteractable
    - Base class with common functionality:
      - UPROPERTY(EditAnywhere, Category="Interaction") FText InteractionText = NSLOCTEXT("Interaction", "Default", "Interact")
      - UPROPERTY(EditAnywhere, Category="Interaction") FGameplayTag InteractionTag -- tag identifying the type
      - UPROPERTY(VisibleAnywhere) UStaticMeshComponent* MeshComponent (root, for visual representation)
      - UPROPERTY(EditAnywhere, Category="Interaction") bool bCanBeInteracted = true
    - Default IInteractable implementations (virtual, overridable):
      - GetInteractionText_Implementation: return InteractionText
      - CanInteract_Implementation: return bCanBeInteracted
      - OnInteract_Implementation: empty (subclasses override)
      - OnFocusBegin_Implementation: empty (for future highlight effects)
      - OnFocusEnd_Implementation: empty
    - Constructor: create MeshComponent as root

    **DoorActor (.h/.cpp):**
    - ADoorActor : public AInteractableBase
    - UPROPERTY(VisibleAnywhere) UStaticMeshComponent* DoorMesh (the door panel, child of root frame)
    - UPROPERTY(EditAnywhere, Category="Door") float OpenAngle = 90.0f
    - UPROPERTY(EditAnywhere, Category="Door") float OpenSpeed = 3.0f (interp speed)
    - UPROPERTY(EditAnywhere, Category="Door") bool bOpensTowardPlayer = true
    - Private: bool bIsOpen = false, float CurrentAngle = 0.0f
    - Constructor: set InteractionText to "Open", InteractionTag to SereneTags::TAG_Interaction_Door
    - OnInteract_Implementation: Toggle bIsOpen. Update InteractionText to "Close"/"Open"
    - Tick: FInterpTo CurrentAngle toward target (0 or +/-OpenAngle based on player side). Apply as DoorMesh relative rotation around Z axis.
    - Determine open direction: On interact, check dot product of player-to-door forward vector to decide which way the door swings

    **PickupActor (.h/.cpp):**
    - APickupActor : public AInteractableBase
    - UPROPERTY(EditAnywhere, Category="Pickup") FName ItemId -- identifier for inventory system (Phase 2)
    - UPROPERTY(EditAnywhere, Category="Pickup") int32 Quantity = 1
    - UPROPERTY(EditAnywhere, Category="Pickup") bool bDestroyOnPickup = true
    - Constructor: set InteractionText to "Pick Up", InteractionTag to SereneTags::TAG_Interaction_Pickup
    - OnInteract_Implementation: Log "Picked up {ItemId} x{Quantity}" with LogSerene. If bDestroyOnPickup, call Destroy(). Phase 2 will add actual inventory integration.
    - NOTE: This actor is a placeholder for Phase 2. The pickup behavior (adding to inventory) will be wired when the inventory system exists. For now, it just logs and destroys.

    **ReadableActor (.h/.cpp):**
    - AReadableActor : public AInteractableBase
    - UPROPERTY(EditAnywhere, Category="Readable", meta=(MultiLine=true)) FText ReadableContent -- the document text
    - UPROPERTY(EditAnywhere, Category="Readable") FText ReadableTitle
    - Constructor: set InteractionText to "Read", InteractionTag to SereneTags::TAG_Interaction_Readable
    - OnInteract_Implementation: Log "Reading: {Title}" with LogSerene. Full text display UI deferred to later. For now, this just fires the interaction and logs.

    **DrawerActor (.h/.cpp):**
    - ADrawerActor : public AInteractableBase
    - UPROPERTY(VisibleAnywhere) UStaticMeshComponent* DrawerMesh (the sliding drawer, child of frame)
    - UPROPERTY(EditAnywhere, Category="Drawer") float OpenDistance = 40.0f (cm slide distance)
    - UPROPERTY(EditAnywhere, Category="Drawer") float OpenSpeed = 4.0f
    - Private: bool bIsOpen = false, float CurrentSlide = 0.0f
    - Constructor: set InteractionText to "Open", InteractionTag to SereneTags::TAG_Interaction_Drawer
    - OnInteract_Implementation: Toggle bIsOpen. Update InteractionText.
    - Tick: FInterpTo CurrentSlide toward target (0 or OpenDistance). Apply as DrawerMesh relative location offset on local X axis (forward slide out).

    IMPORTANT: All actors must #include "Interaction/InteractableInterface.h" and "Tags/SereneTags.h".
    IMPORTANT: DoorActor and DrawerActor need tick-based interpolation for smooth animation. Set PrimaryActorTick.bCanEverTick = true in their constructors. InteractableBase should have tick disabled by default (PrimaryActorTick.bCanEverTick = false) and subclasses opt in.
    IMPORTANT: Use NSLOCTEXT or INVTEXT for FText literals, not FText::FromString for hardcoded display text.
  </action>
  <verify>
    All 5 classes compile. Place a DoorActor in test level with a cube mesh. In PIE, look at it within 1.5m, see prompt. Press E, door rotates open. Press E again, door closes.
    Place a PickupActor -- look at it, see "Pick Up" prompt, press E, log shows pickup message, actor destroyed.
  </verify>
  <done>
    InteractableBase provides common IInteractable implementation. DoorActor smoothly rotates open/closed. PickupActor logs and destroys (ready for Phase 2 inventory). ReadableActor logs title (ready for future UI). DrawerActor slides open/closed. All use gameplay tags for type identification. All use LogSerene logging.
  </done>
</task>

</tasks>

<verification>
1. Place all four actor types in TestMap with placeholder cube/plane meshes
2. Walk up to each within 1.5m -- interaction prompt appears
3. Walk away beyond 1.5m -- prompt disappears
4. Look away from interactable -- prompt disappears
5. Press E on door -- it opens with smooth rotation. Press E again -- closes
6. Press E on pickup -- log message, actor destroyed
7. Press E on readable -- log message
8. Press E on drawer -- slides open smoothly. Press E again -- closes
9. InteractionComponent trace originates from camera (not waist)
</verification>

<success_criteria>
- Interaction detection works via camera-center line trace at 150cm range
- All four actor types respond to interaction correctly
- Focus state management fires OnFocusBegin/End on interactables
- Prompt widget C++ base exists with BindWidget slots for UMG layout
- Interaction system is extensible: any actor implementing IInteractable works automatically
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
