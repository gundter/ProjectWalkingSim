---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - Source/ProjectWalkingSim/Public/Player/Components/StaminaComponent.h
  - Source/ProjectWalkingSim/Private/Player/Components/StaminaComponent.cpp
  - Source/ProjectWalkingSim/Public/Player/Components/HeadBobComponent.h
  - Source/ProjectWalkingSim/Private/Player/Components/HeadBobComponent.cpp
  - Source/ProjectWalkingSim/Public/Player/Components/LeanComponent.h
  - Source/ProjectWalkingSim/Private/Player/Components/LeanComponent.cpp
  - Source/ProjectWalkingSim/Public/Player/SereneCharacter.h
  - Source/ProjectWalkingSim/Private/Player/SereneCharacter.cpp
autonomous: true

must_haves:
  truths:
    - "Stamina drains during sprint and depletes to zero after sustained running"
    - "Stamina does not regenerate until a delay has passed after stopping sprint"
    - "Stamina regenerates smoothly after the delay elapses"
    - "When stamina depletes, player is forced to walk speed"
    - "Head-bob produces visible camera sway that scales with movement speed"
    - "Head-bob can be disabled and the camera remains perfectly still while moving"
    - "Leaning left (Q hold) shifts camera sideways with slight roll"
    - "Leaning right (E hold) shifts camera the opposite direction"
    - "Leaning works both standing and crouched"
  artifacts:
    - path: "Source/ProjectWalkingSim/Public/Player/Components/StaminaComponent.h"
      provides: "Stamina drain/regen system with delegates"
      contains: "UStaminaComponent"
    - path: "Source/ProjectWalkingSim/Public/Player/Components/HeadBobComponent.h"
      provides: "Procedural sine-wave head-bob"
      contains: "UHeadBobComponent"
    - path: "Source/ProjectWalkingSim/Public/Player/Components/LeanComponent.h"
      provides: "Camera-only lean mechanic"
      contains: "ULeanComponent"
  key_links:
    - from: "StaminaComponent"
      to: "SereneCharacter::StartSprint/StopSprint"
      via: "OnStaminaDepleted delegate forces StopSprint"
      pattern: "OnStaminaDepleted"
    - from: "HeadBobComponent"
      to: "UCameraComponent"
      via: "AddRelativeLocation offset each tick"
      pattern: "FMath::Sin.*BobTimer"
    - from: "LeanComponent"
      to: "UCameraComponent"
      via: "SetRelativeLocation/Rotation for lean offset and roll"
      pattern: "FMath::FInterpTo.*LeanDistance"
    - from: "SereneCharacter"
      to: "All three components"
      via: "CreateDefaultSubobject in constructor, UPROPERTY pointers"
      pattern: "CreateDefaultSubobject.*StaminaComponent|HeadBobComponent|LeanComponent"
---

<objective>
Stamina, head-bob, and lean components. These three systems define the movement "feel" of the horror game: weighted sprint with exhaustion, subtle camera motion for immersion, and tactical peeking.

Purpose: Stamina creates the tension loop (sprint to escape, but it runs out). Head-bob grounds the player in the body. Lean enables safe peeking around corners. All are core to the horror experience.

Output: Three UActorComponent subclasses (StaminaComponent, HeadBobComponent, LeanComponent) created, attached to ASereneCharacter, and wired to the input system via the player controller.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StaminaComponent with drain, regen delay, and delegates</name>
  <files>
    Source/ProjectWalkingSim/Public/Player/Components/StaminaComponent.h
    Source/ProjectWalkingSim/Private/Player/Components/StaminaComponent.cpp
  </files>
  <action>
    Create UStaminaComponent : public UActorComponent

    **Header:**
    - ClassGroup=(Custom), meta=(BlueprintSpawnableComponent)
    - Tuning UPROPERTY(EditAnywhere, Category="Stamina"):
      - float MaxStamina = 100.0f
      - float DrainRate = 20.0f (stamina per second while sprinting)
      - float RegenRate = 15.0f (stamina per second during regen)
      - float RegenDelay = 1.5f (seconds after sprint stops before regen begins)
    - Delegates (DECLARE_DYNAMIC_MULTICAST_DELEGATE):
      - FOnStaminaChanged (float Percent) -- fires every tick during drain/regen, ratio 0-1
      - FOnStaminaDepleted -- fires once when stamina hits 0
      - FOnStaminaFull -- fires once when stamina reaches max
    - UPROPERTY(BlueprintAssignable) for each delegate
    - Public functions:
      - void SetSprinting(bool bSprinting) -- called by character
      - float GetStaminaPercent() const
      - bool IsExhausted() const -- true when stamina is 0
      - bool IsSprinting() const

    **Implementation:**
    - TickComponent logic (exactly as in RESEARCH.md code example):
      - If sprinting and stamina > 0: drain by DrainRate * DeltaTime, clamp to 0
      - If stamina hits 0: broadcast OnStaminaDepleted, set internal bIsExhausted = true
      - If not sprinting: accumulate TimeSinceStoppedSprinting += DeltaTime
      - If delay elapsed and stamina < max: regen by RegenRate * DeltaTime, clamp to max
      - If stamina hits max: broadcast OnStaminaFull, clear bIsExhausted
      - Always broadcast OnStaminaChanged with current ratio
    - SetSprinting(true) should reset TimeSinceStoppedSprinting to 0
    - SetSprinting(false) should start the delay countdown
    - If bIsExhausted and player tries to sprint, reject it (return early from SetSprinting(true) until stamina has recovered to at least 20% = ExhaustionThreshold)

    Add ExhaustionThreshold UPROPERTY(EditAnywhere) float = 20.0f -- stamina percent needed to sprint again after depletion. This prevents sprint-tap spam when at 1% stamina.

    IMPORTANT: OnStaminaChanged should only broadcast when the value actually changes (not every tick at max stamina while idle). Check if the ratio changed by more than KINDA_SMALL_NUMBER before broadcasting.
    IMPORTANT: Use LogSerene for all logging, not LogTemp.
  </action>
  <verify>
    Component compiles. Can be added to an actor in editor. DrainRate and RegenRate visible in Details panel. Delegates show in Blueprint event graph.
  </verify>
  <done>
    StaminaComponent drains at 20/s during sprint, waits 1.5s after sprint stops, regens at 15/s. Depleted state prevents re-sprint until 20% recovered. Three delegates broadcast state changes. All values are EditAnywhere for tuning.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HeadBobComponent, LeanComponent, and wire all three to character</name>
  <files>
    Source/ProjectWalkingSim/Public/Player/Components/HeadBobComponent.h
    Source/ProjectWalkingSim/Private/Player/Components/HeadBobComponent.cpp
    Source/ProjectWalkingSim/Public/Player/Components/LeanComponent.h
    Source/ProjectWalkingSim/Private/Player/Components/LeanComponent.cpp
    Source/ProjectWalkingSim/Public/Player/SereneCharacter.h
    Source/ProjectWalkingSim/Private/Player/SereneCharacter.cpp
  </files>
  <action>
    **HeadBobComponent (.h/.cpp):**
    - UHeadBobComponent : public UActorComponent
    - ClassGroup=(Custom), meta=(BlueprintSpawnableComponent)
    - Tuning UPROPERTY(EditAnywhere, Category="Head Bob"):
      - float WalkBobAmplitude = 1.5f (cm vertical at walk speed)
      - float WalkBobFrequency = 8.0f (oscillations/sec at walk speed)
      - float SprintBobMultiplier = 1.8f (amplitude multiplier when sprinting)
      - float CrouchBobMultiplier = 0.6f (amplitude multiplier when crouching)
      - float HorizontalBobRatio = 0.5f (horizontal sway as fraction of vertical)
      - float BobInterpSpeed = 6.0f (fade in/out speed)
    - Private:
      - bool bEnabled = true
      - float BobTimer = 0.0f
      - float CurrentBobAlpha = 0.0f (0 stationary, 1 moving)
      - FVector CurrentBobOffset = FVector::ZeroVector
    - Public:
      - void SetEnabled(bool bEnable) -- controlled by GameInstance setting
      - bool IsEnabled() const
    - TickComponent:
      - Get owner as ACharacter, get velocity magnitude
      - If velocity > 10.0f and bEnabled: interp CurrentBobAlpha toward 1.0
      - Else: interp CurrentBobAlpha toward 0.0
      - Accumulate BobTimer += DeltaTime (frame-rate independent!)
      - Calculate vertical offset: sin(BobTimer * Frequency * 2 * PI) * Amplitude * CurrentBobAlpha
      - Calculate horizontal offset: cos(BobTimer * Frequency * PI) * Amplitude * HorizontalBobRatio * CurrentBobAlpha
      - Apply sprint or crouch multiplier based on character state
      - Store offset in CurrentBobOffset
      - Get camera component from owner, apply offset as relative location ADDITION (not replacement -- lean offset also applies)
    - When disabled (SetEnabled(false)): smoothly interp CurrentBobAlpha to 0, then stop ticking

    **LeanComponent (.h/.cpp):**
    - ULeanComponent : public UActorComponent
    - ClassGroup=(Custom), meta=(BlueprintSpawnableComponent)
    - Tuning UPROPERTY(EditAnywhere, Category="Lean"):
      - float LeanDistance = 30.0f (cm sideways)
      - float LeanRollAngle = 5.0f (degrees camera roll)
      - float LeanSpeed = 8.0f (interp speed)
    - Private:
      - bool bLeaningLeft = false
      - bool bLeaningRight = false
      - float CurrentLeanAlpha = 0.0f (-1 left, 0 center, 1 right)
    - Public:
      - void SetLeanLeft(bool bLean)
      - void SetLeanRight(bool bLean)
      - bool IsLeaning() const
      - float GetLeanAlpha() const
    - TickComponent:
      - Calculate target: -1 (left), 0 (center), 1 (right)
      - FInterpTo CurrentLeanAlpha toward target at LeanSpeed
      - Calculate lateral offset: FVector(0, CurrentLeanAlpha * LeanDistance, 0) in LOCAL space (right vector)
      - Calculate roll: CurrentLeanAlpha * LeanRollAngle
      - Apply to camera component as relative offset and roll ADDITION (combined with head-bob)

    **CRITICAL -- Camera offset strategy for HeadBob + Lean coexistence:**
    Both HeadBobComponent and LeanComponent need to offset the camera. They must NOT fight each other. Strategy:
    - DO NOT have each component call SetRelativeLocation independently.
    - Instead, have both components store their desired offset (CurrentBobOffset, LeanOffset).
    - ASereneCharacter::Tick() reads both offsets and applies the SUM to the camera's relative location/rotation.
    - Add to SereneCharacter:
      - In Tick(): FVector CameraOffset = FVector::ZeroVector; float CameraRoll = 0.0f;
      - If HeadBobComponent: CameraOffset += HeadBobComponent->GetCurrentOffset();
      - If LeanComponent: CameraOffset += LeanComponent->GetLeanOffset(); CameraRoll += LeanComponent->GetLeanRoll();
      - FirstPersonCamera->SetRelativeLocation(BaseCameraLocation + CameraOffset);
      - FirstPersonCamera->SetRelativeRotation(FRotator(0, 0, CameraRoll));
    - Store BaseCameraLocation in BeginPlay (the initial relative location of camera from head bone).
    - Each component exposes GetCurrentOffset() / GetLeanOffset() / GetLeanRoll() as public getters.
    - Components should NOT directly modify the camera -- they compute offsets only.

    **Wire to SereneCharacter:**
    - Add to constructor: CreateDefaultSubobject for StaminaComponent, HeadBobComponent, LeanComponent
    - Replace forward declarations with actual #includes
    - In BeginPlay:
      - Bind StaminaComponent->OnStaminaDepleted to force StopSprint
      - Read GameInstance bHeadBobEnabled setting, call HeadBobComponent->SetEnabled()
    - Update StartSprint() to call StaminaComponent->SetSprinting(true)
    - Update StopSprint() to call StaminaComponent->SetSprinting(false)
    - Add character Tick() with camera offset aggregation as described above

    **Wire lean to PlayerController:**
    - Update SerenePlayerController lean handlers to get LeanComponent and call SetLeanLeft/SetLeanRight instead of just logging

    IMPORTANT: HeadBob timer must use DeltaTime accumulation, NOT frame count. See RESEARCH.md Pitfall 6.
    IMPORTANT: Both components compute offsets but do NOT directly set camera transform. The character aggregates and applies.
    IMPORTANT: When head-bob is disabled via settings, camera should be perfectly stable -- zero offset from head-bob component.
  </action>
  <verify>
    Project compiles. In PIE:
    - Sprint: stamina drain visible in log output (LogSerene messages)
    - Stop sprinting: after ~1.5s, stamina begins regenerating (visible in log)
    - Walking: subtle camera sway visible
    - Sprinting: more pronounced bob visible
    - Disable head-bob in GameInstance: camera perfectly still during movement
    - Hold Q: camera shifts left with slight roll
    - Hold E (long hold): camera shifts right
    - Lean while crouched: works
  </verify>
  <done>
    Three components created and attached to character. Stamina drains/regens with delay. Head-bob produces frame-rate-independent sine-wave camera sway scaling with speed. Lean shifts camera laterally with roll. Camera offset aggregation in character Tick() prevents HeadBob/Lean conflicts. Lean wired to PlayerController input.
  </done>
</task>

</tasks>

<verification>
1. StaminaComponent: Sprint until depleted, verify forced walk. Wait 1.5s, verify regen starts. Verify can't re-sprint until 20% recovered.
2. HeadBobComponent: Walk and observe sway. Sprint and observe increased sway. Toggle off in GameInstance, observe no sway.
3. LeanComponent: Hold Q, camera shifts left. Hold E (long), camera shifts right. Release, camera returns center. Works while crouched.
4. Combined: Sprint with bob + lean simultaneously works without visual glitches.
5. All delegate broadcasts fire correctly (visible via logging or breakpoints).
</verification>

<success_criteria>
- Stamina creates genuine tension: can sprint ~5 seconds before depletion at 20 drain/s from 100 max
- Head-bob is subtle at walk, noticeable at sprint, absent when disabled
- Lean provides ~30cm sideways peek with 5-degree roll
- Camera offset aggregation handles all combinations without glitches
- All values are EditAnywhere for designer tuning
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
